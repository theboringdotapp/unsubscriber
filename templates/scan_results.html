{% extends 'base.html' %}

{% block title %}Scan Results - Gmail Unsubscriber{% endblock %}

{% block head_extra %}
<style>
    /* Inherit checkmark styles from base.html */

    /* Modal overlay */
    /* Inherit modal overlay styles from base.html */

    /* Sender group styles - Keep custom colors logic for now */
    .sender-group {
        border-left: 3px solid hsl(var(--sender-color-hsl, var(--brand))); /* Use HSL */
        margin-bottom: 1rem;
        border-radius: 0 var(--radius) var(--radius) 0; /* Apply border radius */
        background-color: hsl(var(--card)); /* Use card background */
        box-shadow: var(--shadow-sm); /* Add subtle shadow */
        /* overflow: hidden; */ /* Removed this to allow tooltip overflow */
        opacity: 0;
        transform: translateY(10px);
        animation: fadeInUp 0.5s ease forwards;
    }
    
    /* Stagger the animation for sender groups */
    .sender-group:nth-child(1) { animation-delay: 0.1s; }
    .sender-group:nth-child(2) { animation-delay: 0.2s; }
    .sender-group:nth-child(3) { animation-delay: 0.3s; }
    .sender-group:nth-child(4) { animation-delay: 0.4s; }
    .sender-group:nth-child(5) { animation-delay: 0.5s; }
    
    .sender-header {
        padding: 0.75rem 1rem;
        /* Use rgba with HSL variables for background */
        background-color: hsla(var(--sender-color-hsl, var(--brand)), 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid hsl(var(--border)); /* Add border */
    }
    
    .sender-name-container {
        /* cursor: pointer; */ /* This was already here */
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer; /* Keep this one */
    }
    
    .collapse-button {
        cursor: pointer;
        padding: 0.25rem;
        border-radius: var(--radius);
        transition: background-color 0.2s;
        color: hsl(var(--muted-foreground));
    }
    
    .collapse-button:hover {
        background-color: hsl(var(--muted));
        color: hsl(var(--accent-foreground));
    }
    
    .sender-emails {
        overflow: hidden;
        background-color: hsl(var(--card)); /* Ensure background */
        padding: 0; /* Remove padding if emails have their own */
    }
    
    .sender-emails.collapsed {
        display: none;
    }
    
    .sender-name {
        transition: all 0.2s ease;
        font-weight: 500;
        color: hsl(var(--foreground)); /* Use foreground color */
        cursor: pointer; /* Explicitly set cursor here */
    }
    
    .sender-selected .sender-name {
        text-decoration: line-through;
        opacity: 0.7;
    }
    
    /* Email row specific styles */
    .email-row {
        padding: 0.75rem 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid hsl(var(--border));
        transition: all 0.2s ease;
        cursor: pointer; /* Added pointer cursor */
        position: relative;
        overflow: hidden;
    }

    .email-row:last-child {
        border-bottom: none;
    }

    .email-row:hover {
         background-color: hsl(var(--muted));
    }
    
    .email-row:hover::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, hsla(var(--brand), 0.05), transparent);
        transform: translateX(-100%);
        animation: shimmer 1s ease-out;
    }
    
    @keyframes shimmer {
        100% { transform: translateX(100%); }
    }

    .email-selected {
        background-color: hsla(var(--brand), 0.1);
    }

    .email-selected .email-subject {
         text-decoration: line-through;
         opacity: 0.7;
    }
    
    /* Content container with max-width - Inherited from base.html main */

    /* Tooltip styles - Simplified */
    .tooltip {
        position: relative;
        display: inline-flex;
        margin-left: 0.5rem;
    }
    
    .tooltip-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 1.25rem;
        height: 1.25rem;
        border-radius: 50%;
        background-color: hsl(var(--muted-foreground));
        color: hsl(var(--background)); /* Contrast color */
        font-size: 0.75rem;
        font-weight: bold;
        cursor: help;
    }
    
    .tooltip-text {
        visibility: hidden;
        width: 280px;
        background-color: hsl(var(--popover));
        color: hsl(var(--popover-foreground));
        border: 1px solid hsl(var(--border));
        box-shadow: var(--shadow-md);
        border-radius: var(--radius);
        padding: 0.75rem;
        position: absolute;
        z-index: 10;
        bottom: 125%; /* Position above */
        left: 50%;
        transform: translateX(-50%);
        opacity: 0;
        transition: opacity 0.3s;
        font-size: 0.875rem;
        font-weight: normal;
        text-align: left;
        pointer-events: none; /* Allow clicking through */
    }
    
    .tooltip:hover .tooltip-text,
    .tooltip:focus-within .tooltip-text { /* Show on focus within for accessibility */
        visibility: visible;
        opacity: 1;
    }
    
    /* Arrow pointing down from tooltip */
    .tooltip-text::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: hsl(var(--popover)) transparent transparent transparent;
    }
    .dark .tooltip-text::after {
         border-color: hsl(var(--popover)) transparent transparent transparent;
    }

    /* Remove the border applied by the tooltip style itself */
     .tooltip-text { border: none; } /* Remove this border, use shadow */


    /* Table styles (if applicable, can be removed if only using divs) */
    table { width: 100%; border-collapse: collapse; }
    thead { border-bottom: 1px solid hsl(var(--border)); }
    th { padding: 0.75rem 1rem; text-align: left; font-weight: 500; color: hsl(var(--muted-foreground)); }
    td { padding: 0.75rem 1rem; border-bottom: 1px solid hsl(var(--border)); color: hsl(var(--foreground)); }
    tbody tr:last-child td { border-bottom: none; }
    tbody tr:hover { background-color: hsl(var(--muted)); }

    /* Clickable Table Row Style */
    .clickable-row {
        cursor: pointer;
    }
    
    /* Fixed action bar */
    #fixed-action-bar {
        padding: 1rem; /* Adjust padding */
        /* Background and border inherited from base.html */
        transform: translateY(20px);
        opacity: 0;
        transition: all 0.4s ease;
    }
    
    #fixed-action-bar.visible {
        transform: translateY(0);
        opacity: 1;
    }
    
    /* Ensure action bar buttons use new styles */
    #fixed-action-bar .btn {
        /* Style specific buttons if needed */
    }
    
    /* Animation keyframes */
    @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes scaleIn {
        from { transform: scale(0.95); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
    }
    
    /* Title animations */
    h1, .subtitle {
        opacity: 0;
        animation: fadeInUp 0.5s ease forwards;
    }
    
    h1 { animation-delay: 0.1s; }
    .subtitle { animation-delay: 0.2s; }
    
    /* Button pulse effect */
    @keyframes buttonPulse {
        0% { box-shadow: 0 0 0 0 hsla(var(--brand), 0.5); }
        70% { box-shadow: 0 0 0 10px hsla(var(--brand), 0); }
        100% { box-shadow: 0 0 0 0 hsla(var(--brand), 0); }
    }
    
    .btn-pulse {
        animation: buttonPulse 2s infinite;
    }

</style>
{% endblock %}

{% block content %}
<div class="content-container pb-24"> <!-- Add padding-bottom to avoid overlap with fixed bar -->

    <div class="mb-8 text-center">
        <h1 class="text-3xl font-bold text-foreground">Scan Results</h1>
        <p class="text-muted-foreground mt-2 subtitle">Found potential subscriptions. Select emails to unsubscribe or archive.</p>
    </div>

    {% if not subscriptions %}
        <div class="card p-6 text-center" style="opacity: 0; animation: scaleIn 0.5s ease forwards; animation-delay: 0.3s;">
            <p class="text-muted-foreground">No emails with unsubscribe links found in the last {{ config.MAX_SCAN_EMAILS }} scanned messages.</p>
            <a href="{{ url_for('index') }}" class="btn btn-secondary mt-4 focus-ring">Back Home</a>
        </div>
    {% else %}
        <form id="unsubscribe-form">
            <div id="subscription-list" class="space-y-4">
                {% for clean_sender, data in subscriptions.items() %}
                    {% set sender_id = clean_sender|replace(' ', '-')|replace('<', '')|replace('>', '')|replace('@', '-')|replace('.', '-') %}
                    {% set color_index = loop.index0 % colors|length %}
                    {% set sender_color_hsl = colors[color_index] %}
                    <div class="sender-group" 
                         id="sender-group-{{ sender_id }}" 
                         data-sender="{{ clean_sender }}"
                         style="--sender-color-hsl: {{ sender_color_hsl }};">
                        <div class="sender-header">
                            <div class="sender-name-container" onclick='toggleSenderSelection({{ sender_id|tojson }})'>
                                <input type="checkbox" 
                                       id="select-sender-{{ sender_id }}" 
                                       class="sender-checkbox form-checkbox h-4 w-4 text-brand border-border rounded focus:ring-brand" 
                                       data-sender="{{ clean_sender|e }}">
                                <label class="sender-name ml-2">{{ clean_sender }} ({{ data.emails|length }})</label>
                                {% if data.unsubscribe_link %}
                                <span class="tooltip-container">
                                    <a href="{{ data.unsubscribe_link }}" 
                                       target="_blank" 
                                       class="ml-2 text-xs text-brand hover:underline" 
                                       onclick="event.stopPropagation();">Link</a>
                                <!--     <span class="tooltip">
                                        <span class="tooltip-icon">?</span>
                                        <span class="tooltip-text">Primary unsubscribe link found: {{ data.unsubscribe_link }}. Clicking 'Unsubscribe' below might use this or a mailto link from an individual email.</span>
                                    </span> -->
                                </span>
                                {% endif %}
                            </div>
                            <button type="button" class="collapse-button focus-ring" onclick="toggleCollapse('{{ sender_id }}', this)">
                                <svg class="chevron-icon h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                        <div class="sender-emails" id="emails-{{ sender_id }}">
                            {% for email in data.emails %}
                                <div class="email-row" id="email-{{ email.id }}" onclick='toggleEmailSelection({{ email.id|tojson }})'>
                                    <div class="flex items-center flex-1 min-w-0 mr-4">
                                        <input type="checkbox" 
                                               name="email_ids" 
                                               value="{{ email.id }}" 
                                               class="email-checkbox form-checkbox h-4 w-4 text-brand border-border rounded focus:ring-brand mr-3" 
                                               data-sender="{{ clean_sender|e }}"
                                               onclick="event.stopPropagation(); handleEmailCheckboxClick(this);"></input>
                                        <span class="email-subject text-sm text-foreground truncate" title="{{ email.subject|e }}">{{ email.subject }}</span>
                                    </div>
                                    <span class="text-xs text-muted-foreground flex-shrink-0">{{ email.date }}</span>
                                </div>
                            {% endfor %}
                        </div>
                    </div>
                {% endfor %}
            </div>
            
            {% if next_page_token %}
                <div class="mt-8 text-center">
                    <a href="{{ url_for('scan.scan_emails', token=next_page_token) }}"
                       id="scan-more-button"
                       onclick="setLoading('scan-more-button', 'Loading More...')"
                       class="btn btn-outline btn-md focus-ring btn-pulse">
                        Load More Results
                    </a>
                </div>
            {% endif %}
        </form>
    {% endif %}
</div>

<!-- Modal for displaying results -->
<div id="result-modal" class="modal-overlay modal-hidden">
    <div id="modal-content" class="card max-w-md w-full shadow-lg">
        <!-- Content will be loaded here via HTMX or JS -->
    </div>
</div>

<!-- Fixed Action Bar for batch operations -->
<div id="fixed-action-bar" class="fixed bottom-0 left-0 right-0 bg-background border-t border-border shadow-md z-50 hidden">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 flex justify-between items-center">
        <div class="flex items-center space-x-3">
            <span id="action-count" class="text-sm font-medium text-foreground">0 emails selected</span>
            <button type="button" onclick="resetSelection()" class="btn btn-ghost btn-sm text-muted-foreground hover:text-foreground hover:bg-muted focus-ring p-1">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-1"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>
                Reset
            </button>
        </div>
        <div class="flex items-center space-x-3">
            <label for="archive-toggle" class="flex items-center text-sm text-muted-foreground">
                <input type="checkbox" id="archive-toggle" name="archive" checked class="form-checkbox h-4 w-4 text-brand border-border rounded focus:ring-brand mr-2">
                Also archive selected?
            </label>
            <button id="unsubscribe-button" type="button" onclick="performUnsubscribe()" class="btn btn-brand btn-sm focus-ring">
                Unsubscribe & Archive
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Colors are now passed from the backend and applied via Jinja
    const storageKey = 'selectedEmailIds'; // Key for sessionStorage

    // --- Storage Helper Functions ---
    function getSelectedEmailsFromStorage() {
        const stored = sessionStorage.getItem(storageKey);
        try {
            // Store as an array of IDs
            return stored ? JSON.parse(stored) : []; 
        } catch (e) {
            console.error("Error parsing selectedEmails from sessionStorage:", e);
            return []; // Return empty array on error
        }
    }

    function saveSelectedEmailsToStorage(emailIdsArray) {
        try {
            sessionStorage.setItem(storageKey, JSON.stringify(emailIdsArray));
        } catch (e) {
            console.error("Error saving selectedEmails to sessionStorage:", e);
        }
    }

    // Update storage based on checkbox state
    function updateStorageForItem(emailId, isSelected) {
        let selectedIds = getSelectedEmailsFromStorage();
        if (isSelected) {
            if (!selectedIds.includes(emailId)) {
                selectedIds.push(emailId);
            }
        } else {
            selectedIds = selectedIds.filter(id => id !== emailId);
        }
        saveSelectedEmailsToStorage(selectedIds);
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
        loadSelectionFromStorage(); // Check boxes based on storage
        updateActionBar(); // Initial action bar update based on storage
        
        // Add visible class to fixed action bar after a short delay
        setTimeout(() => {
            const actionBar = document.getElementById('fixed-action-bar');
            if (actionBar) {
                actionBar.classList.add('visible');
            }
        }, 600);
    });

    // Check checkboxes on the current page based on stored IDs
    function loadSelectionFromStorage() {
        const selectedIds = getSelectedEmailsFromStorage();
        if (selectedIds.length === 0) return;
        
        selectedIds.forEach(emailId => {
            const checkbox = document.querySelector(`.email-checkbox[value="${emailId}"]`);
            if (checkbox) {
                checkbox.checked = true;
                // Also update the row's selected state
                const emailRow = document.getElementById(`email-${emailId}`);
                if (emailRow) {
                     emailRow.classList.add('email-selected');
                }
            }
        });
        // After checking individual boxes, update sender checkboxes state
        updateAllSenderCheckboxes(); 
    }

    function toggleCollapse(senderId, button) {
        const emailsDiv = document.getElementById(`emails-${senderId}`);
        const icon = button.querySelector('.chevron-icon');
        emailsDiv.classList.toggle('collapsed');
        if (emailsDiv.classList.contains('collapsed')) {
            // Collapsed state: Pointing up
            icon.innerHTML = '<path fill-rule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clip-rule="evenodd" />';
        } else {
            // Expanded state: Pointing down
            icon.innerHTML = '<path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />';
        }
    }

    function toggleSenderSelection(senderId) {
        // Handle the case where senderId might be a string or JSON object
        if (typeof senderId === 'object') {
            senderId = JSON.stringify(senderId).replace(/^"|"$/g, '');
        }
        
        const senderCheckbox = document.getElementById(`select-sender-${senderId}`);
        if (senderCheckbox) {
            // Programmatically toggle the checkbox state
            senderCheckbox.checked = !senderCheckbox.checked;
            // Call the function that handles selecting children and updating storage
            selectAllSenderEmails(senderCheckbox, senderId);
        }
    }

    function selectAllSenderEmails(senderCheckbox, senderId) {
        const emailsDiv = document.getElementById(`emails-${senderId}`);
        const emailCheckboxes = emailsDiv.querySelectorAll('.email-checkbox');
        const senderGroup = document.getElementById(`sender-group-${senderId}`);
        const isChecked = senderCheckbox.checked;

        emailCheckboxes.forEach(cb => {
            cb.checked = isChecked;
            const emailRow = document.getElementById(`email-${cb.value}`);
            if(emailRow) {
                emailRow.classList.toggle('email-selected', isChecked);
            }
            // Update storage for each item
            updateStorageForItem(cb.value, isChecked);
        });
        senderGroup.classList.toggle('sender-selected', isChecked);
        updateActionBar(); // Update count based on storage
    }

    function toggleEmailSelection(emailId) {
        // Handle the case where emailId might be a string or JSON object
        if (typeof emailId === 'object') {
            emailId = JSON.stringify(emailId).replace(/^"|"$/g, '');
        }
        
        const emailCheckbox = document.querySelector(`.email-checkbox[value="${emailId}"]`);
        if (emailCheckbox) {
            emailCheckbox.checked = !emailCheckbox.checked;
            handleEmailCheckboxClick(emailCheckbox);
        }
    }

    function handleEmailCheckboxClick(checkbox) {
        const emailId = checkbox.value;
        const emailRow = document.getElementById(`email-${emailId}`);
        
        if (emailRow) {
            emailRow.classList.toggle('email-selected', checkbox.checked);
        }
        
        // Update storage
        updateStorageForItem(emailId, checkbox.checked);
        
        // Update the parent sender checkbox state
        updateSenderCheckboxState(checkbox);
        
        // Update action bar with count
        updateActionBar();
    }

    function updateSenderCheckboxState(emailCheckbox) {
        // Find the sender this email belongs to
        const sender = emailCheckbox.getAttribute('data-sender');
        if (!sender) return;
        
        // Convert to the same format as the ID
        const senderId = sender.replace(/\s+/g, '-')
                             .replace(/[<>]/g, '')
                             .replace(/@/g, '-')
                             .replace(/\./g, '-');
        
        const senderCheckbox = document.getElementById(`select-sender-${senderId}`);
        if (!senderCheckbox) return;
        
        // Find all email checkboxes for this sender
        const emailsDiv = document.getElementById(`emails-${senderId}`);
        const allEmailCheckboxes = emailsDiv.querySelectorAll('.email-checkbox');
        const checkedEmailCheckboxes = emailsDiv.querySelectorAll('.email-checkbox:checked');
        
        // Update the sender checkbox state based on email selections
        if (checkedEmailCheckboxes.length === 0) {
            // None checked
            senderCheckbox.checked = false;
            senderCheckbox.indeterminate = false;
            document.getElementById(`sender-group-${senderId}`).classList.remove('sender-selected');
        } else if (checkedEmailCheckboxes.length === allEmailCheckboxes.length) {
            // All checked
            senderCheckbox.checked = true;
            senderCheckbox.indeterminate = false;
            document.getElementById(`sender-group-${senderId}`).classList.add('sender-selected');
        } else {
            // Some checked
            senderCheckbox.checked = false;
            senderCheckbox.indeterminate = true;
            document.getElementById(`sender-group-${senderId}`).classList.add('sender-selected');
        }
    }

    function updateAllSenderCheckboxes() {
        // Get all sender checkboxes
        const senderCheckboxes = document.querySelectorAll('.sender-checkbox');
        
        // For each sender, determine the state based on its email checkboxes
        senderCheckboxes.forEach(senderCheckbox => {
            const sender = senderCheckbox.getAttribute('data-sender');
            if (!sender) return;
            
            // Find all email checkboxes for this sender
            const emailCheckboxes = document.querySelectorAll(`.email-checkbox[data-sender="${sender}"]`);
            const checkedEmailCheckboxes = Array.from(emailCheckboxes).filter(cb => cb.checked);
            
            // Update the sender checkbox state
            const senderId = sender.replace(/\s+/g, '-')
                                  .replace(/[<>]/g, '')
                                  .replace(/@/g, '-')
                                  .replace(/\./g, '-');
            const senderGroup = document.getElementById(`sender-group-${senderId}`);
                                  
            if (checkedEmailCheckboxes.length === 0) {
                // None checked
                senderCheckbox.checked = false;
                senderCheckbox.indeterminate = false;
                if (senderGroup) senderGroup.classList.remove('sender-selected');
            } else if (checkedEmailCheckboxes.length === emailCheckboxes.length) {
                // All checked
                senderCheckbox.checked = true;
                senderCheckbox.indeterminate = false;
                if (senderGroup) senderGroup.classList.add('sender-selected');
            } else {
                // Some checked
                senderCheckbox.checked = false;
                senderCheckbox.indeterminate = true;
                if (senderGroup) senderGroup.classList.add('sender-selected');
            }
        });
    }

    function getSelectedEmails() {
        return Array.from(document.querySelectorAll('.email-checkbox:checked')).map(cb => cb.value);
    }

    function updateActionBar() {
        const selectedEmailIds = getSelectedEmailsFromStorage();
        const count = selectedEmailIds.length;
        
        // Get action bar elements
        const actionBar = document.getElementById('fixed-action-bar');
        const actionText = document.getElementById('action-count');
        
        if (!actionBar || !actionText) return;
        
        // Update the count text
        actionText.textContent = count === 1 ? '1 email selected' : `${count} emails selected`;
        
        // Toggle visibility based on selection
        if (count > 0) {
            actionBar.classList.remove('hidden');
        } else {
            actionBar.classList.add('hidden');
        }
    }

    function setLoading(buttonId, loadingText = 'Loading...') {
        const button = document.getElementById(buttonId);
        if (button) {
            button.disabled = true;
            button.classList.add('opacity-50');
            button.textContent = loadingText || 'Loading...';
        }
    }

    function hideLoading(buttonId, originalText = null) {
        const button = document.getElementById(buttonId);
        if (button) {
            button.disabled = false;
            button.classList.remove('opacity-50');
            if (originalText) {
                button.textContent = originalText;
            }
        }
    }

    async function performUnsubscribe() {
        const selectedIdsFromStorage = getSelectedEmailsFromStorage(); // Get ALL selected IDs
        if (selectedIdsFromStorage.length === 0) {
            alert('Please select at least one email to unsubscribe.');
            return;
        }
        
        // Store the IDs we are about to process for removal later
        window.processedEmailIds = [...selectedIdsFromStorage]; 
        
        // Map email IDs to their senders for progress tracking
        const senderMap = {};
        for (const emailId of selectedIdsFromStorage) {
            const checkbox = document.querySelector(`.email-checkbox[value="${emailId}"]`);
            if (checkbox) {
                const sender = checkbox.getAttribute('data-sender');
                if (sender) {
                    if (!senderMap[sender]) {
                        senderMap[sender] = [];
                    }
                    senderMap[sender].push(emailId);
                }
            }
        }
        
        // Convert the map to an array of sender names for display
        const senders = Object.keys(senderMap);
        window.totalSendersToProcess = senders.length;
        window.currentSenderIndex = 0;
        
        const archive = document.getElementById('archive-toggle').checked;
        const buttonId = 'unsubscribe-button';
        
        // Show progress in modal before starting AJAX request
        showUnsubscribeProgressModal(senders);
        
        const formData = new FormData();
        // Send ALL selected IDs from storage to the backend
        selectedIdsFromStorage.forEach(id => formData.append('email_ids', id));
        formData.append('archive', archive ? 'true' : 'false');
        
        const url = "{{ url_for('scan.unsubscribe_and_archive') }}";

        try {
            // Update progress indicator during the request
            const progressInterval = setInterval(() => {
                updateProgress(Math.min(window.currentSenderIndex + 0.5, window.totalSendersToProcess));
            }, 500);
            
            const response = await fetch(url, {
                method: 'POST',
                body: formData
            });
            
            clearInterval(progressInterval);
            
            const resultData = await response.json(); // Expect JSON
            
            if (response.ok && resultData.success) {
                // Show completion modal with results including the full result data
                showModal(renderSuccessModalContent(resultData.message, resultData.http_link, resultData));
                // Clear storage ONLY on successful processing of ALL items
                saveSelectedEmailsToStorage([]); 
            } else {
                // Use error message from backend if available
                const errorMessage = resultData.error || `Request failed with status ${response.status}`;
                showModal(renderErrorModalContent(errorMessage));
                // Don't clear storage on failure
                window.processedEmailIds = []; // Don't remove items on failure
            }

        } catch (error) {
            console.error('Error unsubscribing:', error);
            showModal(renderErrorModalContent('Network error occurred. Please try again.'));
            window.processedEmailIds = [];
        } finally {
            hideLoading(buttonId);
            // Action bar update happens in closeModal or removeProcessedEmails
        }
    }
    
    function showUnsubscribeProgressModal(senders) {
        const totalSenders = senders.length;
        let sendersHtml = '';
        
        // Generate a list of senders with progress indicators
        senders.forEach((sender, index) => {
            sendersHtml += `
            <div class="sender-progress-item flex items-center justify-between py-1" data-sender="${sender}">
                <span class="text-sm text-foreground truncate max-w-[300px]" title="${sender}">${sender}</span>
                <span class="status-indicator flex items-center">
                    <span class="status-text text-xs text-muted-foreground">Waiting</span>
                    <div class="loading-spinner ml-2 w-4 h-4 hidden">
                        <svg class="animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <svg class="check-icon w-4 h-4 text-success hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                    </svg>
                </span>
            </div>`;
        });

        const progressModalHtml = `
        <div class="bg-background rounded-lg p-6">
            <div class="mb-4 text-center">
                <h3 class="text-xl font-semibold text-foreground">Unsubscribing...</h3>
                <p class="text-sm text-muted-foreground mt-2">Sending unsubscribe requests for selected emails.</p>
            </div>
            
            <div class="relative pt-1 mb-4">
                <div class="w-full bg-muted rounded-full">
                    <div id="progress-bar" class="bg-brand h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <div class="flex justify-between text-xs text-muted-foreground mt-1">
                    <span id="progress-text">0/${totalSenders} senders</span>
                    <span id="progress-percentage">0%</span>
                </div>
            </div>
            
            <div class="max-h-60 overflow-y-auto border border-border rounded-md p-2">
                <div id="sender-progress-list">
                    ${sendersHtml}
                </div>
            </div>
        </div>`;
        
        showModal(progressModalHtml);
        
        // Start the first item as processing
        if (senders.length > 0) {
            updateSenderStatus(senders[0], 'processing');
        }
    }
    
    function updateProgress(completedCount) {
        const totalCount = window.totalSendersToProcess || 1;
        const progressPercent = Math.floor((completedCount / totalCount) * 100);
        
        // Update the progress bar
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const progressPercentage = document.getElementById('progress-percentage');
        
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
        if (progressText) progressText.innerText = `${Math.floor(completedCount)}/${totalCount} senders`;
        if (progressPercentage) progressPercentage.innerText = `${progressPercent}%`;
        
        // Mock the progress of sender processing for visual feedback
        const senders = Object.keys(getSenderMap());
        
        if (window.currentSenderIndex < senders.length) {
            // Update the current sender to 'processing'
            const currentSender = senders[window.currentSenderIndex];
            updateSenderStatus(currentSender, 'processing');
            
            // Mark previous senders as 'completed'
            if (window.currentSenderIndex > 0) {
                const previousSender = senders[window.currentSenderIndex - 1];
                updateSenderStatus(previousSender, 'completed');
                window.currentSenderIndex++;
            } else {
                window.currentSenderIndex++;
            }
        }
    }
    
    function getSenderMap() {
        const senderMap = {};
        for (const emailId of window.processedEmailIds || []) {
            const checkbox = document.querySelector(`.email-checkbox[value="${emailId}"]`);
            if (checkbox) {
                const sender = checkbox.getAttribute('data-sender');
                if (sender) {
                    if (!senderMap[sender]) {
                        senderMap[sender] = [];
                    }
                    senderMap[sender].push(emailId);
                }
            }
        }
        return senderMap;
    }
    
    function updateSenderStatus(sender, status) {
        const senderItem = document.querySelector(`.sender-progress-item[data-sender="${sender}"]`);
        if (!senderItem) return;
        
        const statusText = senderItem.querySelector('.status-text');
        const spinner = senderItem.querySelector('.loading-spinner');
        const checkIcon = senderItem.querySelector('.check-icon');
        
        // Reset all indicators
        spinner.classList.add('hidden');
        checkIcon.classList.add('hidden');
        
        if (status === 'waiting') {
            if (statusText) statusText.innerText = 'Waiting';
        } else if (status === 'processing') {
            if (statusText) statusText.innerText = 'Processing';
            spinner.classList.remove('hidden');
        } else if (status === 'completed') {
            if (statusText) statusText.innerText = 'Completed';
            checkIcon.classList.remove('hidden');
        }
    }

    async function performArchiveActionOnly() {
        const selectedIdsFromStorage = getSelectedEmailsFromStorage(); // Get ALL selected IDs
        if (selectedIdsFromStorage.length === 0) {
            alert('Please select at least one email to archive.');
            return;
        }
        
        // Store the IDs we are about to process for removal later
        window.processedEmailIds = [...selectedIdsFromStorage];

        const buttonId = 'archive-only-button';
        setLoading(buttonId, 'Archiving...');

        const formData = new FormData();
        // Send ALL selected IDs from storage to the backend
        selectedIdsFromStorage.forEach(id => formData.append('email_ids', id));
        
        const url = "{{ url_for('scan.archive_emails') }}"; 

        try {
            const response = await fetch(url, {
                method: 'POST',
                body: formData
            });
            const resultData = await response.json(); // Expect JSON

            if (response.ok && resultData.success) {
                showModal(renderSuccessModalContent(resultData.message));
                // Clear storage ONLY on successful processing of ALL items
                saveSelectedEmailsToStorage([]); 
            } else {
                 const errorMessage = resultData.error || `Request failed with status ${response.status}`;
                 showModal(renderErrorModalContent(errorMessage));
                 window.processedEmailIds = []; // Don't remove items or clear storage on failure
            }

        } catch (error) {
            console.error('Error archiving:', error);
            showModal(renderErrorModalContent('Network error occurred during archiving. Please try again.'));
             window.processedEmailIds = [];
        } finally {
            hideLoading(buttonId);
             // Action bar update happens in closeModal or removeProcessedEmails
        }
    }

    function showModal(content) {
        const modal = document.getElementById('result-modal');
        const modalContent = document.getElementById('modal-content');
        modalContent.innerHTML = content;
        modal.classList.remove('modal-hidden');
    }

    function closeModal() {
        const modal = document.getElementById('result-modal');
        modal.classList.add('modal-hidden');
        document.getElementById('modal-content').innerHTML = ''; // Clear content
        updateActionBar(); // Update after closing modal
    }
    
    // Global functions for modal buttons
    window.removeProcessedEmails = function() {
        // Use the stored processedEmailIds set during the action call
        if (window.processedEmailIds && window.processedEmailIds.length > 0) {
            console.log(`Removing ${window.processedEmailIds.length} processed emails from view`);
            
            window.processedEmailIds.forEach(emailId => {
                const emailRow = document.getElementById(`email-${emailId}`);
                if (!emailRow) {
                    console.warn(`Could not find email row with ID: email-${emailId}`);
                    return;
                }
                
                const checkbox = emailRow.querySelector('.email-checkbox');
                const sender = checkbox?.dataset.sender;
                
                // Remove the email row from DOM
                emailRow.remove();
                console.log(`Removed email ID: ${emailId}`);
                
                // Check if sender group is now empty
                if (sender) {
                    // Use the same regex pattern as in other parts of the code
                    const senderId = sender.replace(/\s+/g, '-')
                        .replace(/[<>]/g, '')
                        .replace(/@/g, '-')
                        .replace(/\./g, '-');
                    
                    const senderGroup = document.getElementById(`sender-group-${senderId}`);
                    if (!senderGroup) {
                        console.warn(`Could not find sender group for: ${sender}, ID: ${senderId}`);
                        return;
                    }
                    
                    // Check if the email list div exists and has no more email rows
                    const emailsDiv = senderGroup.querySelector('.sender-emails');
                    if (emailsDiv && emailsDiv.querySelectorAll('.email-row').length === 0) {
                        senderGroup.remove();
                        console.log(`Removed empty sender group: ${sender}`);
                    }
                }
            });
            window.processedEmailIds = []; // Clear the list
        }
        closeModal(); // This calls updateActionBar which reads the (now empty) storage
    }

    window.closeErrorMessage = function() {
        closeModal();
    }

    // Render success modal content dynamically with processed senders summary
    function renderSuccessModalContent(message, http_link = null, resultData = null) {
        console.log("Rendering success modal with:", { message, http_link, resultData });
        
        // Get the list of senders that were processed
        let senders = [];
        let processedEmailIds = [];
        
        // First try to use the backend-provided processed senders list
        if (resultData && resultData.details) {
            if (resultData.details.processed_senders) {
                senders = resultData.details.processed_senders;
                console.log(`Found ${senders.length} processed senders from backend data`);
            }
            
            // If server returned processed email IDs, use those
            if (resultData.details.processed_email_ids) {
                processedEmailIds = resultData.details.processed_email_ids;
                console.log(`Found ${processedEmailIds.length} processed email IDs from backend data`);
                // Update the window.processedEmailIds to ensure we only remove properly processed emails
                window.processedEmailIds = processedEmailIds;
            }
        }
        
        // Fall back to client-side tracking if backend data not available
        if (senders.length === 0) {
            const senderMap = getSenderMap();
            senders = Object.keys(senderMap);
            console.log(`Using client-side fallback, found ${senders.length} senders`);
        }
        
        // Prepare a summary of processed senders
        let senderSummary = '';
        if (senders.length > 0) {
            const maxSendersToShow = 5; // Limit the number of senders shown to avoid cluttering the modal
            const displayedSenders = senders.slice(0, maxSendersToShow);
            const remainingSenders = senders.length - maxSendersToShow;
            
            let sendersList = displayedSenders.map(sender => 
                `<li class="text-sm text-foreground py-1 flex items-center">
                    <svg class="w-4 h-4 text-success mr-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                    </svg>
                    <span class="truncate max-w-[300px]" title="${sender}">${sender}</span>
                </li>`
            ).join('');
            
            if (remainingSenders > 0) {
                sendersList += `<li class="text-sm text-muted-foreground py-1">And ${remainingSenders} more sender${remainingSenders > 1 ? 's' : ''}...</li>`;
            }
            
            senderSummary = `
            <div class="mt-4 text-left w-full">
                <h4 class="text-sm font-medium text-foreground mb-1">Processed senders:</h4>
                <ul class="border border-border rounded-md p-2 max-h-40 overflow-y-auto">
                    ${sendersList}
                </ul>
            </div>`;
        }
        
        // Include http_link if provided
        let linkHtml = '';
        if (http_link) {
            linkHtml = `<p class="text-sm mt-2 text-muted-foreground">If needed, you can <a href="${http_link}" target="_blank" class="text-brand hover:underline focus-ring">visit the link manually</a>.</p>`;
        }
        
        return `
        <div class="bg-background rounded-lg p-6 flex flex-col items-center">
            <div class="text-center">
                <div class="checkmark-container mb-4">
                    <svg class="checkmark" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
                        <circle class="checkmark-circle" cx="26" cy="26" r="25" fill="none"/>
                        <path class="checkmark-check" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8"/>
                    </svg>
                </div>
                <h3 class="text-xl font-semibold text-success mb-2">Success!</h3>
                <p class="text-foreground">${message || "Operation completed successfully."}</p>
                ${linkHtml}
            </div>
            
            ${senderSummary}
            
            <button 
                class="mt-6 btn btn-primary btn-md focus-ring w-full"
                onclick="window.removeProcessedEmails()">
                Done
            </button>
        </div>`;
    }

    // Render error modal content dynamically (no changes needed here, already good)
    function renderErrorModalContent(message) {
        return `
        <div class="bg-background rounded-lg p-6 text-center flex flex-col items-center">
            <div class="error-container mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 text-destructive" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                </svg>
            </div>
            <h3 class="text-xl font-semibold text-destructive mb-2">Error</h3>
            <p class="text-muted-foreground">${message}</p>
            <button 
                class="mt-4 btn btn-secondary focus-ring"
                onclick="closeModal()">
                Close
            </button>
        </div>`;
    }

    function resetSelection() {
        console.log("Resetting selection...");
        // Clear storage
        saveSelectedEmailsToStorage([]);
        
        // Uncheck all visible checkboxes
        document.querySelectorAll('.email-checkbox:checked').forEach(cb => {
            cb.checked = false;
        });
        document.querySelectorAll('.sender-checkbox:checked').forEach(cb => {
            cb.checked = false;
            cb.indeterminate = false; // Reset indeterminate state
        });
        
        // Remove visual selection state from visible rows/groups
        document.querySelectorAll('.email-selected').forEach(row => {
            row.classList.remove('email-selected');
        });
        document.querySelectorAll('.sender-selected').forEach(group => {
            group.classList.remove('sender-selected');
        });
        
        // Update the action bar (which will now hide itself)
        updateActionBar();
    }

</script>
{% endblock %} 