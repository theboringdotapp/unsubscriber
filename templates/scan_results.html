{% extends 'base.html' %}

{% block title %}Scan Results - Gmail Unsubscriber{% endblock %}

{% block head_extra %}
<style>
    /* Inherit checkmark styles from base.html */

    /* Modal overlay */
    /* Inherit modal overlay styles from base.html */

    /* Sender group styles - Keep custom colors logic for now */
    .sender-group {
        border-left: 3px solid hsl(var(--sender-color-hsl, var(--brand))); /* Use HSL */
        margin-bottom: 1rem;
        border-radius: 0 var(--radius) var(--radius) 0; /* Apply border radius */
        background-color: hsl(var(--card)); /* Use card background */
        box-shadow: var(--shadow-sm); /* Add subtle shadow */
        /* overflow: hidden; */ /* Removed this to allow tooltip overflow */
    }
    
    .sender-header {
        padding: 0.75rem 1rem;
        /* Use rgba with HSL variables for background */
        background-color: hsla(var(--sender-color-hsl, var(--brand)), 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid hsl(var(--border)); /* Add border */
    }
    
    .sender-name-container {
        /* cursor: pointer; */ /* This was already here */
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer; /* Keep this one */
    }
    
    .collapse-button {
        cursor: pointer;
        padding: 0.25rem;
        border-radius: var(--radius);
        transition: background-color 0.2s;
        color: hsl(var(--muted-foreground));
    }
    
    .collapse-button:hover {
        background-color: hsl(var(--muted));
        color: hsl(var(--accent-foreground));
    }
    
    .sender-emails {
        overflow: hidden;
        background-color: hsl(var(--card)); /* Ensure background */
        padding: 0; /* Remove padding if emails have their own */
    }
    
    .sender-emails.collapsed {
        display: none;
    }
    
    .sender-name {
        transition: all 0.2s ease;
        font-weight: 500;
        color: hsl(var(--foreground)); /* Use foreground color */
        cursor: pointer; /* Explicitly set cursor here */
    }
    
    .sender-selected .sender-name {
        text-decoration: line-through;
        opacity: 0.7;
    }
    
    /* Email row specific styles */
    .email-row {
        padding: 0.75rem 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid hsl(var(--border));
        transition: background-color 0.15s ease-in-out;
        cursor: pointer; /* Added pointer cursor */
    }

    .email-row:last-child {
        border-bottom: none;
    }

    .email-row:hover {
         background-color: hsl(var(--muted));
    }

    .email-selected {
        background-color: hsla(var(--brand), 0.1);
    }

    .email-selected .email-subject {
         text-decoration: line-through;
         opacity: 0.7;
    }
    
    /* Content container with max-width - Inherited from base.html main */

    /* Tooltip styles - Simplified */
    .tooltip {
        position: relative;
        display: inline-flex;
        margin-left: 0.5rem;
    }
    
    .tooltip-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 1.25rem;
        height: 1.25rem;
        border-radius: 50%;
        background-color: hsl(var(--muted-foreground));
        color: hsl(var(--background)); /* Contrast color */
        font-size: 0.75rem;
        font-weight: bold;
        cursor: help;
    }
    
    .tooltip-text {
        visibility: hidden;
        width: 280px;
        background-color: hsl(var(--popover));
        color: hsl(var(--popover-foreground));
        border: 1px solid hsl(var(--border));
        box-shadow: var(--shadow-md);
        border-radius: var(--radius);
        padding: 0.75rem;
        position: absolute;
        z-index: 10;
        bottom: 125%; /* Position above */
        left: 50%;
        transform: translateX(-50%);
        opacity: 0;
        transition: opacity 0.3s;
        font-size: 0.875rem;
        font-weight: normal;
        text-align: left;
        pointer-events: none; /* Allow clicking through */
    }
    
    .tooltip:hover .tooltip-text,
    .tooltip:focus-within .tooltip-text { /* Show on focus within for accessibility */
        visibility: visible;
        opacity: 1;
    }
    
    /* Arrow pointing down from tooltip */
    .tooltip-text::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: hsl(var(--popover)) transparent transparent transparent;
    }
    .dark .tooltip-text::after {
         border-color: hsl(var(--popover)) transparent transparent transparent;
    }

    /* Remove the border applied by the tooltip style itself */
     .tooltip-text { border: none; } /* Remove this border, use shadow */


    /* Table styles (if applicable, can be removed if only using divs) */
    table { width: 100%; border-collapse: collapse; }
    thead { border-bottom: 1px solid hsl(var(--border)); }
    th { padding: 0.75rem 1rem; text-align: left; font-weight: 500; color: hsl(var(--muted-foreground)); }
    td { padding: 0.75rem 1rem; border-bottom: 1px solid hsl(var(--border)); color: hsl(var(--foreground)); }
    tbody tr:last-child td { border-bottom: none; }
    tbody tr:hover { background-color: hsl(var(--muted)); }

    /* Clickable Table Row Style */
    .clickable-row {
        cursor: pointer;
    }
    
    /* Fixed action bar */
    #fixed-action-bar {
        padding: 1rem; /* Adjust padding */
        /* Background and border inherited from base.html */
    }
    
    /* Ensure action bar buttons use new styles */
    #fixed-action-bar .btn {
        /* Style specific buttons if needed */
    }

</style>
{% endblock %}

{% block content %}
<div class="content-container pb-24"> <!-- Add padding-bottom to avoid overlap with fixed bar -->

    <div class="mb-8 text-center">
        <h1 class="text-3xl font-bold text-foreground">Scan Results</h1>
        <p class="text-muted-foreground mt-2">Found potential subscriptions. Select emails to unsubscribe or archive.</p>
    </div>

    {% if not subscriptions %}
        <div class="card p-6 text-center">
            <p class="text-muted-foreground">No emails with unsubscribe links found in the last {{ config.MAX_SCAN_EMAILS }} scanned messages.</p>
            <a href="{{ url_for('index') }}" class="btn btn-secondary mt-4 focus-ring">Back Home</a>
        </div>
    {% else %}
        <form id="unsubscribe-form">
            <div id="subscription-list" class="space-y-4">
                {% for clean_sender, data in subscriptions.items() %}
                    {% set sender_id = clean_sender|replace(' ', '-')|replace('<', '')|replace('>', '')|replace('@', '-')|replace('.', '-') %}
                    {% set color_index = loop.index0 % colors|length %}
                    {% set sender_color_hsl = colors[color_index] %}
                    <div class="sender-group" 
                         id="sender-group-{{ sender_id }}" 
                         data-sender="{{ clean_sender }}"
                         style="--sender-color-hsl: {{ sender_color_hsl }};">
                        <div class="sender-header">
                            <div class="sender-name-container" onclick='toggleSenderSelection({{ sender_id|tojson }})'>
                                <input type="checkbox" 
                                       id="select-sender-{{ sender_id }}" 
                                       class="sender-checkbox form-checkbox h-4 w-4 text-brand border-border rounded focus:ring-brand" 
                                       data-sender="{{ clean_sender|e }}">
                                <label class="sender-name ml-2">{{ clean_sender }} ({{ data.emails|length }})</label>
                                {% if data.unsubscribe_link %}
                                <span class="tooltip-container">
                                    <a href="{{ data.unsubscribe_link }}" 
                                       target="_blank" 
                                       class="ml-2 text-xs text-brand hover:underline" 
                                       onclick="event.stopPropagation();">Link</a>
                                <!--     <span class="tooltip">
                                        <span class="tooltip-icon">?</span>
                                        <span class="tooltip-text">Primary unsubscribe link found: {{ data.unsubscribe_link }}. Clicking 'Unsubscribe' below might use this or a mailto link from an individual email.</span>
                                    </span> -->
                                </span>
                                {% endif %}
                            </div>
                            <button type="button" class="collapse-button focus-ring" onclick="toggleCollapse('{{ sender_id }}', this)">
                                <svg class="chevron-icon h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                        <div class="sender-emails" id="emails-{{ sender_id }}">
                            {% for email in data.emails %}
                                <div class="email-row" id="email-{{ email.id }}" onclick='toggleEmailSelection({{ email.id|tojson }})'>
                                    <div class="flex items-center flex-1 min-w-0 mr-4">
                                        <input type="checkbox" 
                                               name="email_ids" 
                                               value="{{ email.id }}" 
                                               class="email-checkbox form-checkbox h-4 w-4 text-brand border-border rounded focus:ring-brand mr-3" 
                                               data-sender="{{ clean_sender|e }}"
                                               onclick="event.stopPropagation(); handleEmailCheckboxClick(this);"></input>
                                        <span class="email-subject text-sm text-foreground truncate" title="{{ email.subject|e }}">{{ email.subject }}</span>
                                    </div>
                                    <span class="text-xs text-muted-foreground flex-shrink-0">{{ email.date }}</span>
                                </div>
                            {% endfor %}
                        </div>
                    </div>
                {% endfor %}
            </div>
            
            {% if next_page_token %}
                <div class="mt-8 text-center">
                    <a href="{{ url_for('scan.scan_emails', token=next_page_token) }}"
                       id="scan-more-button"
                       onclick="setLoading('scan-more-button', 'Loading More...')"
                       class="btn btn-outline btn-md focus-ring">
                        Load More Results
                    </a>
                </div>
            {% endif %}
        </form>
    {% endif %}
</div>

<!-- Modal for displaying results -->
<div id="result-modal" class="modal-overlay modal-hidden">
    <div id="modal-content" class="card max-w-md w-full shadow-lg">
        <!-- Content will be loaded here via HTMX or JS -->
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Colors are now passed from the backend and applied via Jinja
    const storageKey = 'selectedEmailIds'; // Key for sessionStorage

    // --- Storage Helper Functions ---
    function getSelectedEmailsFromStorage() {
        const stored = sessionStorage.getItem(storageKey);
        try {
            // Store as an array of IDs
            return stored ? JSON.parse(stored) : []; 
        } catch (e) {
            console.error("Error parsing selectedEmails from sessionStorage:", e);
            return []; // Return empty array on error
        }
    }

    function saveSelectedEmailsToStorage(emailIdsArray) {
        try {
            sessionStorage.setItem(storageKey, JSON.stringify(emailIdsArray));
        } catch (e) {
            console.error("Error saving selectedEmails to sessionStorage:", e);
        }
    }

    // Update storage based on checkbox state
    function updateStorageForItem(emailId, isSelected) {
        let selectedIds = getSelectedEmailsFromStorage();
        if (isSelected) {
            if (!selectedIds.includes(emailId)) {
                selectedIds.push(emailId);
            }
        } else {
            selectedIds = selectedIds.filter(id => id !== emailId);
        }
        saveSelectedEmailsToStorage(selectedIds);
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
        loadSelectionFromStorage(); // Check boxes based on storage
        updateActionBar(); // Initial action bar update based on storage
    });

    // Check checkboxes on the current page based on stored IDs
    function loadSelectionFromStorage() {
        const selectedIds = getSelectedEmailsFromStorage();
        if (selectedIds.length === 0) return;
        
        selectedIds.forEach(emailId => {
            const checkbox = document.querySelector(`.email-checkbox[value="${emailId}"]`);
            if (checkbox) {
                checkbox.checked = true;
                // Also update the row's selected state
                const emailRow = document.getElementById(`email-${emailId}`);
                if (emailRow) {
                     emailRow.classList.add('email-selected');
                }
            }
        });
        // After checking individual boxes, update sender checkboxes state
        updateAllSenderCheckboxes(); 
    }

    function toggleCollapse(senderId, button) {
        const emailsDiv = document.getElementById(`emails-${senderId}`);
        const icon = button.querySelector('.chevron-icon');
        emailsDiv.classList.toggle('collapsed');
        if (emailsDiv.classList.contains('collapsed')) {
            // Collapsed state: Pointing up
            icon.innerHTML = '<path fill-rule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clip-rule="evenodd" />';
        } else {
            // Expanded state: Pointing down
            icon.innerHTML = '<path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />';
        }
    }

    function toggleSenderSelection(senderId) {
        const senderCheckbox = document.getElementById(`select-sender-${senderId}`);
        if (senderCheckbox) {
            // Programmatically toggle the checkbox state
            senderCheckbox.checked = !senderCheckbox.checked;
            // Call the function that handles selecting children and updating storage
            selectAllSenderEmails(senderCheckbox, senderId);
        }
    }

    function selectAllSenderEmails(senderCheckbox, senderId) {
        const emailsDiv = document.getElementById(`emails-${senderId}`);
        const emailCheckboxes = emailsDiv.querySelectorAll('.email-checkbox');
        const senderGroup = document.getElementById(`sender-group-${senderId}`);
        const isChecked = senderCheckbox.checked;

        emailCheckboxes.forEach(cb => {
            cb.checked = isChecked;
            const emailRow = document.getElementById(`email-${cb.value}`);
            if(emailRow) {
                emailRow.classList.toggle('email-selected', isChecked);
            }
            // Update storage for each item
            updateStorageForItem(cb.value, isChecked);
        });
        senderGroup.classList.toggle('sender-selected', isChecked);
        updateActionBar(); // Update count based on storage
    }

    function toggleEmailSelection(emailId) {
         const emailCheckbox = document.querySelector(`.email-checkbox[value="${emailId}"]`);
         if (emailCheckbox) {
            emailCheckbox.checked = !emailCheckbox.checked;
            handleEmailCheckboxClick(emailCheckbox);
         } 
    }

    function handleEmailCheckboxClick(emailCheckbox) {
        const emailRow = document.getElementById(`email-${emailCheckbox.value}`);
        if (emailRow) {
             emailRow.classList.toggle('email-selected', emailCheckbox.checked);
        }
        // Update storage for this item
        updateStorageForItem(emailCheckbox.value, emailCheckbox.checked);
        
        // Update parent sender checkbox state
        updateSenderCheckboxState(emailCheckbox.dataset.sender);

        updateActionBar(); // Update count based on storage
    }

    // Helper to update a single sender checkbox based on its children
    function updateSenderCheckboxState(sender) {
        const senderId = sender.replace(' ', '-').replace('<', '').replace('>', '').replace('@', '-').replace('.', '-');
        const senderCheckbox = document.getElementById(`select-sender-${senderId}`);
        const senderGroup = document.getElementById(`sender-group-${senderId}`);
        if (!senderCheckbox || !senderGroup) return; // Sender group might not be on this page
        
        const allEmailsForSender = senderGroup.querySelectorAll(`.email-checkbox[data-sender="${sender}"]`);
        if (allEmailsForSender.length === 0) return; // No emails for this sender on the page
        
        const allChecked = Array.from(allEmailsForSender).every(cb => cb.checked);
        const someChecked = Array.from(allEmailsForSender).some(cb => cb.checked);
        
        senderCheckbox.checked = allChecked;
        senderCheckbox.indeterminate = someChecked && !allChecked;
        senderGroup.classList.toggle('sender-selected', someChecked);
    }
    
    // Helper to update all sender checkboxes on the page (e.g., after load)
    function updateAllSenderCheckboxes() {
        const senderCheckboxes = document.querySelectorAll('.sender-checkbox');
        senderCheckboxes.forEach(cb => {
            updateSenderCheckboxState(cb.dataset.sender);
        });
    }

    function getSelectedEmails() {
        return Array.from(document.querySelectorAll('.email-checkbox:checked')).map(cb => cb.value);
    }

    function updateActionBar() {
        const selectedIdsFromStorage = getSelectedEmailsFromStorage(); // Get total count from storage
        const count = selectedIdsFromStorage.length;
        const actionBar = document.getElementById('fixed-action-bar');
        
        if (count > 0) {
            actionBar.innerHTML = `
                <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 flex justify-between items-center">
                    <div class="flex items-center space-x-3">
                        <span class="text-sm font-medium text-foreground">${count} email${count > 1 ? 's' : ''} selected</span>
                        <button type="button" onclick="resetSelection()" class="btn btn-ghost btn-sm text-muted-foreground hover:text-foreground hover:bg-muted focus-ring p-1">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-1"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>
                            Reset
                        </button>
                    </div>
                    <div class="flex items-center space-x-3">
                        <label for="archive-toggle" class="flex items-center text-sm text-muted-foreground">
                            <input type="checkbox" id="archive-toggle" name="archive" checked class="form-checkbox h-4 w-4 text-brand border-border rounded focus:ring-brand mr-2">
                            Also archive selected?
                        </label>
                        <button id="unsubscribe-button" type="button" onclick="performUnsubscribe()" class="btn btn-brand btn-sm focus-ring">
                            Unsubscribe & Archive
                        </button>
                    </div>
                </div>
            `;
            actionBar.classList.remove('hidden');
            
            // Update button text based on archive toggle
            const archiveToggle = document.getElementById('archive-toggle');
            const unsubscribeButton = document.getElementById('unsubscribe-button');
            archiveToggle.addEventListener('change', () => {
                 unsubscribeButton.textContent = archiveToggle.checked ? 'Unsubscribe & Archive' : 'Unsubscribe Only';
            });
            unsubscribeButton.textContent = archiveToggle.checked ? 'Unsubscribe & Archive' : 'Unsubscribe Only'; // Initial text

        } else {
            actionBar.classList.add('hidden');
            actionBar.innerHTML = ''; // Clear content
        }
    }

    async function performUnsubscribe() {
        const selectedIdsFromStorage = getSelectedEmailsFromStorage(); // Get ALL selected IDs
        if (selectedIdsFromStorage.length === 0) {
            alert('Please select at least one email to unsubscribe.');
            return;
        }
        
        // Store the IDs we are about to process for removal later
        window.processedEmailIds = [...selectedIdsFromStorage]; 
        
        const archive = document.getElementById('archive-toggle').checked;
        const buttonId = 'unsubscribe-button';
        setLoading(buttonId, archive ? 'Processing...' : 'Processing...'); // Use a generic message

        const formData = new FormData();
        // Send ALL selected IDs from storage to the backend
        selectedIdsFromStorage.forEach(id => formData.append('email_ids', id));
        formData.append('archive', archive ? 'true' : 'false');
        
        const url = "{{ url_for('scan.unsubscribe_and_archive') }}";

        try {
            const response = await fetch(url, {
                method: 'POST',
                body: formData
            });
            
            const resultData = await response.json(); // Expect JSON
            
            if (response.ok && resultData.success) {
                showModal(renderSuccessModalContent(resultData.message, resultData.http_link));
                // Clear storage ONLY on successful processing of ALL items
                saveSelectedEmailsToStorage([]); 
            } else {
                // Use error message from backend if available
                const errorMessage = resultData.error || `Request failed with status ${response.status}`;
                showModal(renderErrorModalContent(errorMessage));
                 // Don't clear storage on failure
                 window.processedEmailIds = []; // Don't remove items on failure
            }

        } catch (error) {
            console.error('Error unsubscribing:', error);
            showModal(renderErrorModalContent('Network error occurred. Please try again.'));
             window.processedEmailIds = [];
        } finally {
            hideLoading(buttonId);
            // Action bar update happens in closeModal or removeProcessedEmails
        }
    }

    async function performArchiveActionOnly() {
        const selectedIdsFromStorage = getSelectedEmailsFromStorage(); // Get ALL selected IDs
        if (selectedIdsFromStorage.length === 0) {
            alert('Please select at least one email to archive.');
            return;
        }
        
        // Store the IDs we are about to process for removal later
        window.processedEmailIds = [...selectedIdsFromStorage];

        const buttonId = 'archive-only-button';
        setLoading(buttonId, 'Archiving...');

        const formData = new FormData();
        // Send ALL selected IDs from storage to the backend
        selectedIdsFromStorage.forEach(id => formData.append('email_ids', id));
        
        const url = "{{ url_for('scan.archive_emails') }}"; 

        try {
            const response = await fetch(url, {
                method: 'POST',
                body: formData
            });
            const resultData = await response.json(); // Expect JSON

            if (response.ok && resultData.success) {
                showModal(renderSuccessModalContent(resultData.message));
                // Clear storage ONLY on successful processing of ALL items
                saveSelectedEmailsToStorage([]); 
            } else {
                 const errorMessage = resultData.error || `Request failed with status ${response.status}`;
                 showModal(renderErrorModalContent(errorMessage));
                 window.processedEmailIds = []; // Don't remove items or clear storage on failure
            }

        } catch (error) {
            console.error('Error archiving:', error);
            showModal(renderErrorModalContent('Network error occurred during archiving. Please try again.'));
             window.processedEmailIds = [];
        } finally {
            hideLoading(buttonId);
             // Action bar update happens in closeModal or removeProcessedEmails
        }
    }

    function showModal(content) {
        const modal = document.getElementById('result-modal');
        const modalContent = document.getElementById('modal-content');
        modalContent.innerHTML = content;
        modal.classList.remove('modal-hidden');
    }

    function closeModal() {
        const modal = document.getElementById('result-modal');
        modal.classList.add('modal-hidden');
        document.getElementById('modal-content').innerHTML = ''; // Clear content
        updateActionBar(); // Update after closing modal
    }
    
    // Global functions for modal buttons
    window.removeProcessedEmails = function() {
        // Use the stored processedEmailIds set during the action call
        if (window.processedEmailIds && window.processedEmailIds.length > 0) {
            window.processedEmailIds.forEach(emailId => {
                const emailRow = document.getElementById(`email-${emailId}`);
                const sender = emailRow?.querySelector('.email-checkbox')?.dataset.sender;
                emailRow?.remove();
                
                // Check if sender group is now empty
                if (sender) {
                    const senderId = sender.replace(' ', '-').replace('<', '').replace('>', '').replace('@', '-').replace('.', '-');
                    const senderGroup = document.getElementById(`sender-group-${senderId}`);
                    // Check if the email list div exists and has no more email rows
                    const emailsDiv = senderGroup?.querySelector('.sender-emails');
                    if (emailsDiv && emailsDiv.querySelectorAll('.email-row').length === 0) {
                        senderGroup.remove();
                    }
                }
            });
            window.processedEmailIds = []; // Clear the list
        }
        closeModal(); // This calls updateActionBar which reads the (now empty) storage
    }

    window.closeErrorMessage = function() {
        closeModal();
    }

    // Render success modal content dynamically
    function renderSuccessModalContent(message, http_link = null) {
        let linkHtml = '';
        if (http_link) {
            linkHtml = `<p class="text-sm mt-2 text-muted-foreground">If needed, you can <a href="${http_link}" target="_blank" class="text-brand hover:underline focus-ring">visit the link manually</a>.</p>`;
        }
        return `
        <div class="bg-background rounded-lg p-6 text-center flex flex-col items-center">
            <div class="checkmark-container mb-4">
                <svg class="checkmark" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
                    <circle class="checkmark-circle" cx="26" cy="26" r="25" fill="none"/>
                    <path class="checkmark-check" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8"/>
                </svg>
            </div>
            <h3 class="text-xl font-semibold text-success mb-2">Success!</h3>
            <p class="text-foreground">${message || "Operation completed successfully."}</p>
            ${linkHtml}
            <button 
                class="mt-6 btn btn-primary btn-md focus-ring"
                onclick="window.removeProcessedEmails()">
                Done
            </button>
        </div>`;
    }

    // Render error modal content dynamically (no changes needed here, already good)
    function renderErrorModalContent(message) {
        return `
        <div class="bg-background rounded-lg p-6 text-center flex flex-col items-center">
            <div class="error-container mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 text-destructive" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                </svg>
            </div>
            <h3 class="text-xl font-semibold text-destructive mb-2">Error</h3>
            <p class="text-muted-foreground">${message}</p>
            <button 
                class="mt-4 btn btn-secondary focus-ring"
                onclick="closeModal()">
                Close
            </button>
        </div>`;
    }

    function resetSelection() {
        console.log("Resetting selection...");
        // Clear storage
        saveSelectedEmailsToStorage([]);
        
        // Uncheck all visible checkboxes
        document.querySelectorAll('.email-checkbox:checked').forEach(cb => {
            cb.checked = false;
        });
        document.querySelectorAll('.sender-checkbox:checked').forEach(cb => {
            cb.checked = false;
            cb.indeterminate = false; // Reset indeterminate state
        });
        
        // Remove visual selection state from visible rows/groups
        document.querySelectorAll('.email-selected').forEach(row => {
            row.classList.remove('email-selected');
        });
        document.querySelectorAll('.sender-selected').forEach(group => {
            group.classList.remove('sender-selected');
        });
        
        // Update the action bar (which will now hide itself)
        updateActionBar();
    }

</script>
{% endblock %} 