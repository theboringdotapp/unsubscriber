{% extends 'base.html' %}

{% block title %}Scan Results - Gmail Unsubscriber{% endblock %}

{% block head_extra %}
<style>
    /* Sender group styles with custom colors */
    .sender-group {
        border-left: 3px solid hsl(var(--sender-color-hsl, var(--brand))); /* Use HSL */
        margin-bottom: 1rem;
        border-radius: 0 var(--radius) var(--radius) 0; /* Apply border radius */
        background-color: hsl(var(--card)); /* Use card background */
        box-shadow: var(--shadow-sm); /* Add subtle shadow */
        /* overflow: hidden; */ /* Removed this to allow tooltip overflow */
        opacity: 0;
        transform: translateY(10px);
        animation: fadeInUp 0.5s ease forwards;
    }
    
    /* Stagger the animation for sender groups */
    .sender-group:nth-child(1) { animation-delay: 0.1s; }
    .sender-group:nth-child(2) { animation-delay: 0.2s; }
    .sender-group:nth-child(3) { animation-delay: 0.3s; }
    .sender-group:nth-child(4) { animation-delay: 0.4s; }
    .sender-group:nth-child(5) { animation-delay: 0.5s; }
    
    .sender-header {
        padding: 0.75rem 1rem;
        /* Use rgba with HSL variables for background */
        background-color: hsla(var(--sender-color-hsl, var(--brand)), 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid hsl(var(--border)); /* Add border */
    }
    
    .sender-name-container {
        /* cursor: pointer; */ /* This was already here */
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer; /* Keep this one */
    }
    
    .collapse-button {
        cursor: pointer;
        padding: 0.25rem;
        border-radius: var(--radius);
        transition: background-color 0.2s;
        color: hsl(var(--muted-foreground));
    }
    
    .collapse-button:hover {
        background-color: hsl(var(--muted));
        color: hsl(var(--accent-foreground));
    }
    
    .sender-emails {
        overflow: hidden;
        background-color: hsl(var(--card)); /* Ensure background */
        padding: 0; /* Remove padding if emails have their own */
    }
    
    .sender-emails.collapsed {
        display: none;
    }
    
    .sender-name {
        transition: all 0.2s ease;
        font-weight: 500;
        color: hsl(var(--foreground)); /* Use foreground color */
        cursor: pointer; /* Explicitly set cursor here */
    }
    
    .sender-selected .sender-name {
        text-decoration: line-through;
        opacity: 0.7;
    }
    
    /* Email row specific styles */
    .email-row {
        padding: 0.75rem 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid hsl(var(--border));
        transition: all 0.2s ease;
        cursor: pointer; /* Added pointer cursor */
        position: relative;
        overflow: hidden;
    }

    .email-row:last-child {
        border-bottom: none;
    }

    .email-row:hover {
         background-color: hsl(var(--muted));
    }
    
    .email-row:hover::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, hsla(var(--brand), 0.05), transparent);
        transform: translateX(-100%);
        animation: shimmer 1s ease-out;
    }
    
    @keyframes shimmer {
        100% { transform: translateX(100%); }
    }

    .email-selected {
        background-color: hsla(var(--brand), 0.1);
    }

    .email-selected .email-subject {
         text-decoration: line-through;
         opacity: 0.7;
    }
    
    /* Content container with max-width - Inherited from base.html main */

    /* Tooltip styles - Simplified */
    .tooltip {
        position: relative;
        display: inline-flex;
        margin-left: 0.5rem;
    }
    
    .tooltip-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 1.25rem;
        height: 1.25rem;
        border-radius: 50%;
        background-color: hsl(var(--muted-foreground));
        color: hsl(var(--background)); /* Contrast color */
        font-size: 0.75rem;
        font-weight: bold;
        cursor: help;
    }
    
    .tooltip-text {
        visibility: hidden;
        width: auto;
        min-width: 200px;
        background-color: hsl(var(--popover));
        color: hsl(var(--popover-foreground));
        border: 1px solid hsl(var(--border));
        box-shadow: var(--shadow-md);
        border-radius: var(--radius);
        padding: 0.75rem;
        position: absolute;
        z-index: 10;
        bottom: 125%; /* Position above */
        left: 50%;
        transform: translateX(-50%);
        opacity: 0;
        transition: opacity 0.3s;
        font-size: 0.875rem;
        font-weight: normal;
        text-align: left;
        pointer-events: none; /* Allow clicking through */
    }
    
    .tooltip:hover .tooltip-text,
    .tooltip:focus-within .tooltip-text { /* Show on focus within for accessibility */
        visibility: visible;
        opacity: 1;
    }
    
    /* Arrow pointing down from tooltip */
    .tooltip-text::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: hsl(var(--popover)) transparent transparent transparent;
    }
    .dark .tooltip-text::after {
         border-color: hsl(var(--popover)) transparent transparent transparent;
    }

    /* Remove the border applied by the tooltip style itself */
     .tooltip-text { border: none; } /* Remove this border, use shadow */


    /* Table styles (if applicable, can be removed if only using divs) */
    table { width: 100%; border-collapse: collapse; }
    thead { border-bottom: 1px solid hsl(var(--border)); }
    th { padding: 0.75rem 1rem; text-align: left; font-weight: 500; color: hsl(var(--muted-foreground)); }
    td { padding: 0.75rem 1rem; border-bottom: 1px solid hsl(var(--border)); color: hsl(var(--foreground)); }
    tbody tr:last-child td { border-bottom: none; }
    tbody tr:hover { background-color: hsl(var(--muted)); }

    /* Clickable Table Row Style */
    .clickable-row {
        cursor: pointer;
    }
    
    /* Fixed action bar */
    #fixed-action-bar {
        padding: 1rem; /* Adjust padding */
        /* Background and border inherited from base.html */
        transform: translateY(20px);
        opacity: 0;
        transition: all 0.4s ease;
    }
    
    #fixed-action-bar.visible {
        transform: translateY(0);
        opacity: 1;
    }
    
    /* Ensure action bar buttons use new styles */
    #fixed-action-bar .btn {
        /* Style specific buttons if needed */
    }
    
    /* Animation keyframes */
    @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes scaleIn {
        from { transform: scale(0.95); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
    }
    
    /* Title animations */
    h1, .subtitle {
        opacity: 0;
        animation: fadeInUp 0.5s ease forwards;
    }
    
    h1 { animation-delay: 0.1s; }
    .subtitle { animation-delay: 0.2s; }
    
    /* Button pulse effect */
    @keyframes buttonPulse {
        0% { box-shadow: 0 0 0 0 hsla(var(--brand), 0.5); }
        70% { box-shadow: 0 0 0 10px hsla(var(--brand), 0); }
        100% { box-shadow: 0 0 0 0 hsla(var(--brand), 0); }
    }
    
    .btn-pulse {
        animation: buttonPulse 2s infinite;
    }

</style>
{% endblock %}

{% block content %}
<div class="content-container pb-24"> <!-- Add padding-bottom to avoid overlap with fixed bar -->

    <div class="mb-8 text-center">
        <h1 class="text-3xl font-bold text-foreground">Subscriptions</h1>
        <p class="text-muted-foreground mt-2 subtitle">Found potential subscriptions based on your latest {{ config.MAX_SCAN_EMAILS }} inbox emails.</p>
    </div>

    {% if not subscriptions and not current_page_token %} {# Check if it's the very first empty scan #}
        <div class="card p-8 text-center max-w-lg mx-auto mt-10" style="opacity: 0; animation: scaleIn 0.5s ease forwards; animation-delay: 0.3s;">
            <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-12 w-12 text-muted-foreground mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">
                <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                <path stroke-linecap="round" stroke-linejoin="round" d="M15 15l6 6" />
            </svg>
            <h3 class="text-lg font-medium text-foreground mb-2">No Subscriptions Found Yet</h3>
            <p class="text-muted-foreground mb-6">We scanned the most recent emails in your inbox but didn't find any with obvious unsubscribe links in the headers.</p>
            <p class="text-xs text-muted-foreground mb-4">This can happen if emails use non-standard unsubscribe methods or if you haven't received many subscription emails recently.</p>
            <a href="{{ url_for('index') }}" class="btn btn-secondary mt-4 focus-ring">Back Home</a>
        </div>
    {% elif subscriptions %}
        <form id="unsubscribe-form">
            <div id="subscription-list" class="space-y-4">
                {% for clean_sender, data in subscriptions.items() %}
                    {% set sender_id = clean_sender|replace(' ', '-')|replace('<', '')|replace('>', '')|replace('@', '-')|replace('.', '-') %}
                    {% set color_index = loop.index0 % colors|length %}
                    {% set sender_color_hsl = colors[color_index] %}
                    <div class="sender-group" 
                         id="sender-group-{{ sender_id }}" 
                         data-sender="{{ clean_sender }}"
                         style="--sender-color-hsl: {{ sender_color_hsl }};">
                        <div class="sender-header">
                            <div class="sender-name-container" onclick='toggleSenderSelection({{ sender_id|tojson }})'>
                                <input type="checkbox" 
                                       id="select-sender-{{ sender_id }}" 
                                       class="sender-checkbox form-checkbox h-4 w-4 text-brand border-border rounded focus:ring-brand" 
                                       data-sender="{{ clean_sender|e }}">
                                <label class="sender-name ml-2">{{ clean_sender }} ({{ data.emails|length }})</label>
                                {% if data.unsubscribe_link %}
                                <span class="tooltip-container">
                                    <a href="{{ data.unsubscribe_link }}" 
                                       target="_blank" 
                                       class="ml-2 text-xs text-brand hover:underline" 
                                       onclick="event.stopPropagation();">Link</a>
                                </span>
                                {% endif %}
                            </div>
                            <button type="button" class="collapse-button focus-ring" onclick="toggleCollapse('{{ sender_id }}', this)">
                                <svg class="chevron-icon h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                        <div class="sender-emails" id="emails-{{ sender_id }}">
                            {% for email in data.emails %}
                                <div class="email-row" id="email-{{ email.id }}" onclick='toggleEmailSelection({{ email.id|tojson }})'>
                                    <div class="flex items-center flex-1 min-w-0 mr-4">
                                        <input type="checkbox" 
                                               name="email_ids" 
                                               value="{{ email.id }}" 
                                               class="email-checkbox form-checkbox h-4 w-4 text-brand border-border rounded focus:ring-brand mr-3" 
                                               data-sender="{{ clean_sender|e }}"
                                               onclick="event.stopPropagation(); handleEmailCheckboxClick(this);"></input>
                                        <span class="email-subject text-sm text-foreground truncate" title="{{ email.subject|e }}">{{ email.subject }}</span>
                                    </div>
                                    <span class="text-xs text-muted-foreground flex-shrink-0">{{ email.date }}</span>
                                </div>
                            {% endfor %}
                        </div>
                    </div>
                {% endfor %}
            </div>
            
            {# Pagination/End of Results Logic #}
            {% if subscriptions %} {# Only show pagination controls if there are *some* results #}
                {% if next_page_token %}
                    <div class="mt-8 text-center">
                        <a href="{{ url_for('scan.scan_emails', token=next_page_token) }}"
                           id="scan-more-button"
                           onclick="setLoading('scan-more-button', 'Scanning More...')"
                           class="btn btn-outline btn-md focus-ring btn-pulse">
                            Scan More Emails
                        </a>
                    </div>
                {% else %}
                    {# Display an "End of Results" message #}
                    <div class="mt-10 text-center text-muted-foreground flex flex-col items-center">
                         <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                        </svg>
                        <p>You've reached the end of the scannable emails.</p>
                    </div>
                {% endif %}
            {% endif %}
            {# End Pagination Logic #}
        </form>
    {% endif %}
</div>

<!-- Modal for displaying results -->
<div id="result-modal" class="modal-overlay modal-hidden">
    <div id="modal-content" class="card max-w-md w-full shadow-lg">
        <!-- Content will be loaded here via HTMX or JS -->
    </div>
</div>

<!-- Modal for requesting additional permissions -->
<div id="permission-modal" class="modal-overlay modal-hidden">
    <div class="card max-w-md w-full shadow-lg bg-background p-6">
        <div class="text-center mb-4">
            <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" class="mx-auto mb-4 text-brand">
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                <path d="M9 12l2 2 4-4"></path>
            </svg>
            <h3 class="text-xl font-semibold text-foreground">Additional Permissions Required</h3>
        </div>
        
        <div class="text-foreground mb-6 text-sm">
            <p class="mb-3">To enable archiving functionality, the application needs permission to modify your emails (specifically to archive them by removing the "Inbox" label).</p>
            
            <div class="bg-muted/50 p-3 rounded-md mb-3">
                <h4 class="font-medium mb-2">What this permission allows:</h4>
                <ul class="list-disc pl-5 space-y-1 text-muted-foreground">
                    <li>Archiving selected emails after unsubscribing</li>
                    <li>Moving emails out of your inbox</li>
                </ul>
            </div>
            
            <div class="bg-muted/50 p-3 rounded-md">
                <h4 class="font-medium mb-2">What we don't do:</h4>
                <ul class="list-disc pl-5 space-y-1 text-muted-foreground">
                    <li>We never delete your emails</li>
                    <li>We never read email content beyond processing unsubscribe links</li>
                    <li>We never send emails on your behalf (except for triggering mailto: unsubscribe links)</li>
                </ul>
            </div>
        </div>
        
        <div class="flex flex-col sm:flex-row gap-3 sm:justify-end">
            <button type="button" onclick="closePermissionModal()" class="btn btn-outline btn-sm focus-ring order-1 sm:order-0">
                Cancel
            </button>
            <!-- Button to trigger permission upgrade -->
            <a href="{{ url_for('auth.login') }}?scope=modify&return_to={{ request.url | urlencode }}" class="btn btn-brand btn-sm focus-ring order-0 sm:order-1">
                Allow Access
            </a>
        </div>
    </div>
</div>

<!-- Fixed Action Bar for batch operations - redesigned for mobile compatibility -->
<div id="fixed-action-bar" class="fixed bottom-0 left-0 right-0 bg-background border-t border-border shadow-md z-50 hidden">
    <div class="max-w-7xl mx-auto px-4 py-3 sm:px-6 lg:px-8">
        <!-- Responsive layout - stacked on mobile, horizontal on larger screens -->
        <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-3">
            <!-- Left side - selection info and progress -->
            <div class="flex flex-col space-y-1 sm:max-w-xs">
                <div class="flex items-center justify-between">
                    <span id="action-count" class="text-sm font-medium text-foreground">0 emails selected</span>
                    <button type="button" onclick="resetSelection()" class="text-xs text-brand hover:underline flex items-center gap-1">
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>
                        Reset
                    </button>
                </div>
                <div class="w-full sm:w-48 h-1.5 bg-muted rounded-full">
                    <div id="email-limit-progress" class="h-full bg-brand rounded-full" style="width: 0%"></div>
                </div>
                <span class="text-xs text-muted-foreground"><span id="email-count-current">0</span>/<span id="email-count-max">25</span> emails</span>
            </div>
            
            <!-- Right side - action controls -->
            <div class="flex flex-col sm:flex-row sm:items-center gap-2">
                <div class="flex flex-col gap-1 sm:mr-2">
                    {% if has_archive_permission %}
                    <label for="archive-toggle" class="flex items-center text-sm text-muted-foreground shrink-0 cursor-pointer">
                        <input type="checkbox" id="archive-toggle" name="archive" class="form-checkbox h-4 w-4 text-brand border-border rounded focus:ring-brand mr-2 cursor-pointer">
                        <span>Archive emails</span>
                    </label>
                    {% else %}
                    <label for="archive-toggle" class="flex items-center text-sm text-muted-foreground shrink-0 cursor-not-allowed opacity-60" title="Archiving requires additional permissions">
                        <input type="checkbox" id="archive-toggle" name="archive" disabled class="form-checkbox h-4 w-4 text-gray-400 border-border rounded focus:ring-brand mr-2 cursor-not-allowed">
                        <span>Archive unavailable</span>
                    </label>
                    <a href="#" onclick="showPermissionModal(); return false;" class="text-xs text-brand hover:underline flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="mr-1">
                            <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                        </svg>
                        Enable archiving
                    </a>
                    {% endif %}
                </div>
                <button id="unsubscribe-button" type="button" onclick="performUnsubscribe()" class="btn btn-brand btn-sm focus-ring w-full sm:w-auto">
                    Unsubscribe
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Colors are now passed from the backend and applied via Jinja
    const storageKey = 'selectedEmailIds'; // Key for sessionStorage
    const MAX_EMAILS = 25; // Maximum number of emails that can be selected/processed at once

    // --- Storage Helper Functions ---
    const detailsStorageKey = 'emailDetails'; // Key for storing detailed email information
    
    function getSelectedEmailsFromStorage() {
        const stored = sessionStorage.getItem(storageKey);
        try {
            // Store as an array of IDs
            return stored ? JSON.parse(stored) : []; 
        } catch (e) {
            console.error("Error parsing selectedEmails from sessionStorage:", e);
            return []; // Return empty array on error
        }
    }

    function saveSelectedEmailsToStorage(emailIdsArray) {
        try {
            sessionStorage.setItem(storageKey, JSON.stringify(emailIdsArray));
        } catch (e) {
            console.error("Error saving selectedEmails to sessionStorage:", e);
        }
    }
    
    function getEmailDetailsFromStorage() {
        const stored = sessionStorage.getItem(detailsStorageKey);
        try {
            return stored ? JSON.parse(stored) : {};
        } catch (e) {
            console.error("Error parsing emailDetails from sessionStorage:", e);
            return {};
        }
    }
    
    function saveEmailDetailsToStorage(emailDetailsObj) {
        try {
            sessionStorage.setItem(detailsStorageKey, JSON.stringify(emailDetailsObj));
        } catch (e) {
            console.error("Error saving emailDetails to sessionStorage:", e);
        }
    }

    // Update storage based on checkbox state
    function updateStorageForItem(emailId, isSelected) {
        let selectedIds = getSelectedEmailsFromStorage();
        if (isSelected) {
            if (!selectedIds.includes(emailId)) {
                selectedIds.push(emailId);
                
                // Also store detailed information for this email if available
                const emailRow = document.getElementById(`email-${emailId}`);
                if (emailRow) {
                    const checkbox = emailRow.querySelector('.email-checkbox');
                    if (checkbox) {
                        const sender = checkbox.getAttribute('data-sender');
                        
                        // Get the sender group element to find unsubscribe link
                        let unsubscribeLink = null;
                        if (sender) {
                            const senderId = sender.replace(/\s+/g, '-')
                                .replace(/[<>]/g, '')
                                .replace(/@/g, '-')
                                .replace(/\./g, '-');
                            
                            const senderGroup = document.getElementById(`sender-group-${senderId}`);
                            if (senderGroup) {
                                const headerLinks = senderGroup.querySelectorAll('.sender-header a');
                                if (headerLinks.length > 0) {
                                    unsubscribeLink = headerLinks[0].getAttribute('href') || null;
                                }
                            }
                        }
                        
                        // Store the email details
                        const emailDetails = getEmailDetailsFromStorage();
                        emailDetails[emailId] = {
                            id: emailId,
                            sender: sender || null,
                            link: unsubscribeLink,
                            type: unsubscribeLink ? (unsubscribeLink.startsWith('mailto:') ? 'mailto' : 'http') : null
                        };
                        saveEmailDetailsToStorage(emailDetails);
                    }
                }
            }
        } else {
            selectedIds = selectedIds.filter(id => id !== emailId);
            
            // Remove this email from the details storage as well
            const emailDetails = getEmailDetailsFromStorage();
            if (emailDetails[emailId]) {
                delete emailDetails[emailId];
                saveEmailDetailsToStorage(emailDetails);
            }
        }
        saveSelectedEmailsToStorage(selectedIds);
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
        loadSelectionFromStorage(); // Check boxes based on storage
        updateActionBar(); // Initial action bar update based on storage
        markProcessedSenders(); // Mark senders processed in this session
        
        // Add visible class to fixed action bar after a short delay
        setTimeout(() => {
            const actionBar = document.getElementById('fixed-action-bar');
            if (actionBar) {
                actionBar.classList.add('visible');
            }
        }, 600);
    });

    function storeProcessedSenders(senders) {
        const processedKey = 'processedSenders';
        let existingSenders = [];
        try {
            const stored = sessionStorage.getItem(processedKey);
            existingSenders = stored ? JSON.parse(stored) : [];
        } catch (e) {
            console.error("Error parsing processedSenders from sessionStorage:", e);
            existingSenders = [];
        }
        
        // Add new senders without duplication
        const updatedSenders = [...new Set([...existingSenders, ...senders])];
        
        try {
            sessionStorage.setItem(processedKey, JSON.stringify(updatedSenders));
            console.log("Stored processed senders:", updatedSenders);
        } catch (e) {
            console.error("Error saving processedSenders to sessionStorage:", e);
        }
    }
    
    function getProcessedSenders() {
        const processedKey = 'processedSenders';
        try {
            const stored = sessionStorage.getItem(processedKey);
            return stored ? JSON.parse(stored) : [];
        } catch (e) {
            console.error("Error retrieving processedSenders:", e);
            return [];
        }
    }
    
    function markProcessedSenders() {
        const processedSenders = getProcessedSenders();
        if (processedSenders.length === 0) return;
        
        console.log("Marking processed senders:", processedSenders);
        
        document.querySelectorAll('.sender-group').forEach(group => {
            const senderName = group.getAttribute('data-sender');
            if (senderName && processedSenders.includes(senderName)) {
                const senderNameContainer = group.querySelector('.sender-name-container');
                if (senderNameContainer && !senderNameContainer.querySelector('.processed-indicator-tooltip')) {
                    // Add a tooltip structure around the checkmark
                    const tooltipWrapper = document.createElement('span');
                    tooltipWrapper.classList.add('processed-indicator-tooltip', 'tooltip', 'ml-2'); // Use existing tooltip class
                    
                    const iconSpan = document.createElement('span');
                    iconSpan.classList.add('tooltip-icon-placeholder', 'text-muted-foreground'); // Placeholder, maybe style differently
                    iconSpan.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                        </svg>
                    `;
                    
                    const tooltipText = document.createElement('span');
                    tooltipText.classList.add('tooltip-text'); // Use existing tooltip style
                    tooltipText.textContent = 'Already Unsubscribed';
                    
                    tooltipWrapper.appendChild(iconSpan);
                    tooltipWrapper.appendChild(tooltipText);
                    
                    senderNameContainer.appendChild(tooltipWrapper);
                }
            }
        });
    }

    // Check checkboxes on the current page based on stored IDs
    function loadSelectionFromStorage() {
        const selectedIds = getSelectedEmailsFromStorage();
        if (selectedIds.length === 0) return;
        
        selectedIds.forEach(emailId => {
            const checkbox = document.querySelector(`.email-checkbox[value="${emailId}"]`);
            if (checkbox) {
                checkbox.checked = true;
                // Also update the row's selected state
                const emailRow = document.getElementById(`email-${emailId}`);
                if (emailRow) {
                     emailRow.classList.add('email-selected');
                }
            }
        });
        // After checking individual boxes, update sender checkboxes state
        updateAllSenderCheckboxes(); 
    }

    function toggleCollapse(senderId, button) {
        const emailsDiv = document.getElementById(`emails-${senderId}`);
        const icon = button.querySelector('.chevron-icon');
        emailsDiv.classList.toggle('collapsed');
        if (emailsDiv.classList.contains('collapsed')) {
            // Collapsed state: Pointing up
            icon.innerHTML = '<path fill-rule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clip-rule="evenodd" />';
        } else {
            // Expanded state: Pointing down
            icon.innerHTML = '<path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />';
        }
    }

    function toggleSenderSelection(senderId) {
        // Handle the case where senderId might be a string or JSON object
        if (typeof senderId === 'object') {
            senderId = JSON.stringify(senderId).replace(/^"|"$/g, '');
        }
        
        const senderCheckbox = document.getElementById(`select-sender-${senderId}`);
        if (senderCheckbox) {
            // Programmatically toggle the checkbox state
            senderCheckbox.checked = !senderCheckbox.checked;
            // Call the function that handles selecting children and updating storage
            selectAllSenderEmails(senderCheckbox, senderId);
        }
    }

    function selectAllSenderEmails(senderCheckbox, senderId) {
        const emailsDiv = document.getElementById(`emails-${senderId}`);
        const emailCheckboxes = emailsDiv.querySelectorAll('.email-checkbox');
        const senderGroup = document.getElementById(`sender-group-${senderId}`);
        const isChecked = senderCheckbox.checked;

        // If trying to select all and would exceed limit, show warning
        if (isChecked) {
            const selectedEmailIds = getSelectedEmailsFromStorage();
            const currentlyChecked = Array.from(emailCheckboxes).filter(cb => cb.checked).length;
            const toBeAdded = Array.from(emailCheckboxes).filter(cb => !cb.checked).length;
            
            if (selectedEmailIds.length + toBeAdded > MAX_EMAILS) {
                alert(`Selecting all emails from this sender would exceed the maximum limit of ${MAX_EMAILS}. Please select fewer emails.`);
                senderCheckbox.checked = false;
                senderCheckbox.indeterminate = currentlyChecked > 0;
                return;
            }
        }

        emailCheckboxes.forEach(cb => {
            cb.checked = isChecked;
            const emailRow = document.getElementById(`email-${cb.value}`);
            if(emailRow) {
                emailRow.classList.toggle('email-selected', isChecked);
            }
            // Update storage for each item
            updateStorageForItem(cb.value, isChecked);
        });
        senderGroup.classList.toggle('sender-selected', isChecked);
        updateActionBar(); // Update count based on storage
    }

    function toggleEmailSelection(emailId) {
        // Handle the case where emailId might be a string or JSON object
        if (typeof emailId === 'object') {
            emailId = JSON.stringify(emailId).replace(/^"|"$/g, '');
        }
        
        const emailCheckbox = document.querySelector(`.email-checkbox[value="${emailId}"]`);
        if (emailCheckbox) {
            // Check if we're trying to select (not deselect) and are at the limit
            const selectedEmailIds = getSelectedEmailsFromStorage();
            if (!emailCheckbox.checked && selectedEmailIds.length >= MAX_EMAILS) {
                alert(`Maximum selection limit reached (${MAX_EMAILS}). Please unselect some emails before selecting more.`);
                return;
            }
            
            emailCheckbox.checked = !emailCheckbox.checked;
            handleEmailCheckboxClick(emailCheckbox);
        }
    }

    function handleEmailCheckboxClick(checkbox) {
        const emailId = checkbox.value;
        const emailRow = document.getElementById(`email-${emailId}`);
        
        if (emailRow) {
            emailRow.classList.toggle('email-selected', checkbox.checked);
        }
        
        // Update storage
        updateStorageForItem(emailId, checkbox.checked);
        
        // Update the parent sender checkbox state
        updateSenderCheckboxState(checkbox);
        
        // Update action bar with count
        updateActionBar();
    }

    function updateSenderCheckboxState(emailCheckbox) {
        // Find the sender this email belongs to
        const sender = emailCheckbox.getAttribute('data-sender');
        if (!sender) return;
        
        // Convert to the same format as the ID
        const senderId = sender.replace(/\s+/g, '-')
                             .replace(/[<>]/g, '')
                             .replace(/@/g, '-')
                             .replace(/\./g, '-');
        
        const senderCheckbox = document.getElementById(`select-sender-${senderId}`);
        if (!senderCheckbox) return;
        
        // Find all email checkboxes for this sender
        const emailsDiv = document.getElementById(`emails-${senderId}`);
        const allEmailCheckboxes = emailsDiv.querySelectorAll('.email-checkbox');
        const checkedEmailCheckboxes = emailsDiv.querySelectorAll('.email-checkbox:checked');
        
        // Update the sender checkbox state based on email selections
        if (checkedEmailCheckboxes.length === 0) {
            // None checked
            senderCheckbox.checked = false;
            senderCheckbox.indeterminate = false;
            document.getElementById(`sender-group-${senderId}`).classList.remove('sender-selected');
        } else if (checkedEmailCheckboxes.length === allEmailCheckboxes.length) {
            // All checked
            senderCheckbox.checked = true;
            senderCheckbox.indeterminate = false;
            document.getElementById(`sender-group-${senderId}`).classList.add('sender-selected');
        } else {
            // Some checked
            senderCheckbox.checked = false;
            senderCheckbox.indeterminate = true;
            document.getElementById(`sender-group-${senderId}`).classList.add('sender-selected');
        }
    }

    function updateAllSenderCheckboxes() {
        // Get all sender checkboxes
        const senderCheckboxes = document.querySelectorAll('.sender-checkbox');
        
        // For each sender, determine the state based on its email checkboxes
        senderCheckboxes.forEach(senderCheckbox => {
            const sender = senderCheckbox.getAttribute('data-sender');
            if (!sender) return;
            
            // Find all email checkboxes for this sender
            const emailCheckboxes = document.querySelectorAll(`.email-checkbox[data-sender="${sender}"]`);
            const checkedEmailCheckboxes = Array.from(emailCheckboxes).filter(cb => cb.checked);
            
            // Update the sender checkbox state
            const senderId = sender.replace(/\s+/g, '-')
                                  .replace(/[<>]/g, '')
                                  .replace(/@/g, '-')
                                  .replace(/\./g, '-');
            const senderGroup = document.getElementById(`sender-group-${senderId}`);
                                  
            if (checkedEmailCheckboxes.length === 0) {
                // None checked
                senderCheckbox.checked = false;
                senderCheckbox.indeterminate = false;
                if (senderGroup) senderGroup.classList.remove('sender-selected');
            } else if (checkedEmailCheckboxes.length === emailCheckboxes.length) {
                // All checked
                senderCheckbox.checked = true;
                senderCheckbox.indeterminate = false;
                if (senderGroup) senderGroup.classList.add('sender-selected');
            } else {
                // Some checked
                senderCheckbox.checked = false;
                senderCheckbox.indeterminate = true;
                if (senderGroup) senderGroup.classList.add('sender-selected');
            }
        });
    }

    function getSelectedEmails() {
        return Array.from(document.querySelectorAll('.email-checkbox:checked')).map(cb => cb.value);
    }

    function updateActionBar() {
        const selectedEmailIds = getSelectedEmailsFromStorage();
        const count = selectedEmailIds.length;
        
        // Get action bar elements
        const actionBar = document.getElementById('fixed-action-bar');
        const actionText = document.getElementById('action-count');
        const progressBar = document.getElementById('email-limit-progress');
        const emailCountCurrent = document.getElementById('email-count-current');
        const emailCountMax = document.getElementById('email-count-max');
        
        if (!actionBar || !actionText) return;
        
        // Update the count text
        actionText.textContent = count === 1 ? '1 email selected' : `${count} emails selected`;
        
        // Update progress bar
        if (progressBar && emailCountCurrent && emailCountMax) {
            const progressPercent = (count / MAX_EMAILS) * 100;
            progressBar.style.width = `${progressPercent}%`;
            emailCountCurrent.textContent = count;
            emailCountMax.textContent = MAX_EMAILS;
            
            // Change progress bar color when approaching limit
            if (progressPercent >= 90) {
                progressBar.classList.remove('bg-brand');
                progressBar.style.backgroundColor = 'rgb(245, 158, 11)'; // Amber-500 color
            } else {
                progressBar.style.backgroundColor = ''; // Reset to default
                progressBar.classList.add('bg-brand');
            }
        }
        
        // Toggle visibility based on selection
        if (count > 0) {
            actionBar.classList.remove('hidden');
        } else {
            actionBar.classList.add('hidden');
        }
    }

    function setLoading(buttonId, loadingText = 'Loading...') {
        const button = document.getElementById(buttonId);
        if (button) {
            button.disabled = true;
            button.classList.add('opacity-50');
            button.textContent = loadingText || 'Loading...';
        }
    }

    function hideLoading(buttonId, originalText = null) {
        const button = document.getElementById(buttonId);
        if (button) {
            button.disabled = false;
            button.classList.remove('opacity-50');
            if (originalText) {
                button.textContent = originalText;
            }
        }
    }

    async function performUnsubscribe() {
        const selectedIdsFromStorage = getSelectedEmailsFromStorage(); // Get ALL selected IDs
        if (selectedIdsFromStorage.length === 0) {
            alert('Please select at least one email to unsubscribe.');
            return;
        }
        
        // Check against the global MAX_EMAILS constant
        if (selectedIdsFromStorage.length > MAX_EMAILS) {
            alert(`For reliable processing, please limit your selection to ${MAX_EMAILS} emails at a time. Currently ${selectedIdsFromStorage.length} are selected.`);
            return;
        }
        
        // Map email IDs to their senders for processing
        const senderMap = {};
        const emailsWithNoLinks = [];
        const allEmailDetails = [];
        
        // Get stored email details for all selected emails
        const storedEmailDetails = getEmailDetailsFromStorage();
        
        // First analyze all selected emails to categorize them
        for (const emailId of selectedIdsFromStorage) {
            let sender = null;
            let unsubscribeLink = null;
            let emailRow = null;
            
            // First check if we have the details stored in sessionStorage
            if (storedEmailDetails[emailId]) {
                const details = storedEmailDetails[emailId];
                sender = details.sender;
                unsubscribeLink = details.link;
                
                console.log(`Using stored details for email ${emailId}: sender=${sender}, link=${unsubscribeLink}`);
            } else {
                // Fallback to checking the DOM if the email is on the current page
                const checkbox = document.querySelector(`.email-checkbox[value="${emailId}"]`);
                
                if (checkbox) {
                    // Email is on current page
                    sender = checkbox.getAttribute('data-sender');
                    emailRow = document.getElementById(`email-${emailId}`);
                    
                    // Extract unsubscribe link if available
                    // Try to find the link in different ways
                    // First check for direct links from email row
                    if (emailRow) {
                        const linkElements = emailRow.querySelectorAll('a.unsubscribe-link, a.email-link');
                        if (linkElements.length > 0) {
                            unsubscribeLink = linkElements[0].getAttribute('href');
                        }
                    }
                    
                    // If no link found in email row, try to find sender's primary unsubscribe link
                    if (!unsubscribeLink && sender) {
                        // Find the sender group element
                        const senderId = sender.replace(/\s+/g, '-')
                            .replace(/[<>]/g, '')
                            .replace(/@/g, '-')
                            .replace(/\./g, '-');
                        
                        const senderGroup = document.getElementById(`sender-group-${senderId}`);
                        if (senderGroup) {
                            const headerLinks = senderGroup.querySelectorAll('.sender-header a');
                            if (headerLinks.length > 0) {
                                unsubscribeLink = headerLinks[0].getAttribute('href');
                            }
                        }
                    }
                    
                    // Save this info to storage for future use
                    if (sender) {
                        storedEmailDetails[emailId] = {
                            id: emailId,
                            sender: sender,
                            link: unsubscribeLink,
                            type: unsubscribeLink ? (unsubscribeLink.startsWith('mailto:') ? 'mailto' : 'http') : null
                        };
                        saveEmailDetailsToStorage(storedEmailDetails);
                    }
                } else {
                    // Email is not on current page and we don't have stored details
                    console.log(`Email ID ${emailId} not found on current page and no stored details, will be processed by backend`);
                    emailsWithNoLinks.push(emailId);
                    continue;
                }
            }
            
            if (!sender) {
                console.warn(`Missing sender for email ID: ${emailId}`);
                emailsWithNoLinks.push(emailId);
                continue;
            }
            
            // Store email details
            const emailDetails = {
                id: emailId,
                sender: sender,
                link: unsubscribeLink
            };
            
            allEmailDetails.push(emailDetails);
            
            // Group by sender
            if (!senderMap[sender]) {
                senderMap[sender] = [];
            }
            senderMap[sender].push(emailId);
            
            // Track emails with no links
            if (!unsubscribeLink) {
                emailsWithNoLinks.push(emailId);
            }
        }
        
        const senders = Object.keys(senderMap);
        window.totalSendersToProcess = senders.length;
        window.currentSenderIndex = 0;
        
        // To handle emails not on the current page, we'll send all IDs to the backend
        // that aren't being processed on the client side
        const shouldArchive = document.getElementById('archive-toggle').checked;
        const buttonId = 'unsubscribe-button';
        
        // Show progress modal and get link maps
        const { httpLinks, mailtoLinks } = showUnsubscribeProgressModal(senders);
        
        // Process HTTP links on the client side
        const httpSenders = Object.keys(httpLinks);
        const mailtoSenders = Object.keys(mailtoLinks);
        
        console.log(`Processing client-side: ${httpSenders.length} HTTP links, ${mailtoSenders.length} mailto links`);
        console.log(`${emailsWithNoLinks.length} emails have no direct unsubscribe links or are from other pages`);
        
        const successfullyProcessedIds = [];
        const manuallyRequiredIds = [];  // Track IDs requiring manual action
        const failedIds = [];
        const errors = [];
        let lastHttpLink = null;
        
        // Client-side HTTP link processing
        console.log(`Starting to process ${httpSenders.length} HTTP links in parallel`);
        
        // Process all HTTP links concurrently using Promise.all
        const httpPromises = httpSenders.map(async (sender) => {
            const link = httpLinks[sender];
            updateSenderStatus(sender, 'processing');
            
            try {
                console.log(`Processing HTTP link for ${sender}: ${link}`);
                
                // Store for the modal (prioritize manual links)
                if (!lastHttpLink) {
                    lastHttpLink = link;
                }
                
                let automaticSuccess = false;
                
                if (link) {
                    try {
                        // Make a background HTTP request instead of opening a tab
                        console.log(`Fetching link in background: ${link}`);
                        
                        // Using fetch with a timeout to avoid hanging
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                        
                        const response = await fetch(link, {
                            method: 'GET',
                            mode: 'no-cors', // Important for cross-origin requests
                            redirect: 'follow',
                            signal: controller.signal
                        });
                        
                        clearTimeout(timeoutId);
                        
                        // Check if it's likely the unsubscribe was successful
                        // In no-cors mode, we don't have full response details, but we can assume success if it didn't throw
                        automaticSuccess = true;
                        console.log(`Successfully fetched ${link} for ${sender}`);
                        
                    } catch (fetchError) {
                        console.warn(`Fetch request failed for ${link}: ${fetchError.message}`);
                        automaticSuccess = false;
                    }
                }
                
                // Mark as requiring manual action or automated success
                const senderEmailIds = senderMap[sender] || [];
                
                if (automaticSuccess) {
                    // Automatic success
                    senderEmailIds.forEach(id => {
                        if (!successfullyProcessedIds.includes(id)) {
                            successfullyProcessedIds.push(id);
                        }
                    });
                    
                    updateSenderStatus(sender, 'completed');
                } else {
                    // Manual action required
                    senderEmailIds.forEach(id => {
                        if (!manuallyRequiredIds.includes(id)) {
                            manuallyRequiredIds.push(id);
                        }
                    });
                    
                    // Update UI to show manual action required with link
                    updateSenderStatus(sender, 'manual', 'http');
                }
                
                window.currentSenderIndex++;
                updateProgress(window.currentSenderIndex);
                
                return { 
                    success: automaticSuccess, 
                    manualRequired: !automaticSuccess,
                    sender,
                    link 
                };
                
            } catch (error) {
                console.error(`Error processing HTTP link for ${sender}:`, error);
                errors.push(`Failed to process unsubscribe for ${sender}: ${error.message}`);
                failedIds.push(...(senderMap[sender] || []));
                updateSenderStatus(sender, 'error');
                
                return { success: false, sender, error };
            }
        });
        
        // Wait for all HTTP link processing to complete
        await Promise.all(httpPromises);
        console.log(`Completed processing ${httpSenders.length} HTTP links`);
        
        // Process mailto links and any remaining emails through the backend
        const emailsForBackend = [...emailsWithNoLinks];
        mailtoSenders.forEach(sender => {
            emailsForBackend.push(...(senderMap[sender] || []));
        });
        
        // Add any emails from session storage that weren't found on this page
        const emailIdsOnCurrentPage = Array.from(document.querySelectorAll('.email-checkbox')).map(cb => cb.value);
        const emailIdsNotOnPage = selectedIdsFromStorage.filter(id => !emailIdsOnCurrentPage.includes(id));
        emailIdsNotOnPage.forEach(id => {
            if (!emailsForBackend.includes(id)) {
                console.log(`Adding email ID ${id} from another page to backend processing`);
                emailsForBackend.push(id);
            }
        });
        
        if (emailsForBackend.length > 0) {
            console.log(`Sending ${emailsForBackend.length} emails to backend for mailto/server processing`);
            
            const formData = new FormData();
            emailsForBackend.forEach(id => formData.append('email_ids', id));
            formData.append('archive', 'false'); // We'll do batch archiving separately
            
            const url = "{{ url_for('scan.unsubscribe_and_archive') }}";
            
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    body: formData
                });
                
                const resultData = await response.json();
                
                if (response.ok && resultData.success) {
                    console.log('Backend processing successful');
                    
                    // Add backend-processed IDs to our list
                    if (resultData.details && resultData.details.processed_email_ids) {
                        resultData.details.processed_email_ids.forEach(id => {
                            if (!successfullyProcessedIds.includes(id)) {
                                successfullyProcessedIds.push(id);
                            }
                        });
                    }
                    
                    // Update processing status for backend-processed senders
                    if (resultData.details && resultData.details.processed_senders) {
                        resultData.details.processed_senders.forEach(sender => {
                            updateSenderStatus(sender, 'completed');
                        });
                    }
                    
                    // Get any HTTP link from backend
                    if (resultData.http_link && !lastHttpLink) {
                        lastHttpLink = resultData.http_link;
                    }
                    
                } else {
                    console.error('Backend processing error:', resultData.error);
                    errors.push(resultData.error || 'Backend processing failed');
                    
                    // Add error details if available
                    if (resultData.details) {
                        if (resultData.details.unsubscribe_errors) {
                            errors.push(...resultData.details.unsubscribe_errors);
                        }
                    }
                }
                
            } catch (error) {
                console.error('Error during backend processing:', error);
                errors.push(`Network error during backend processing: ${error.message}`);
            }
        }
        
        // Ensure all selected emails from storage are included in the processing
        selectedIdsFromStorage.forEach(id => {
            if (!successfullyProcessedIds.includes(id) && !manuallyRequiredIds.includes(id) && !failedIds.includes(id)) {
                // This email wasn't explicitly tracked anywhere, so consider it processed by backend
                successfullyProcessedIds.push(id);
            }
        });
        
        // Perform batch archive if needed
        if (shouldArchive && selectedIdsFromStorage.length > 0) {
            console.log(`Batch archiving ${selectedIdsFromStorage.length} emails`);
            
            const formData = new FormData();
            // Always use ALL emails from session storage for archiving
            selectedIdsFromStorage.forEach(id => formData.append('email_ids', id));
            
            try {
                const response = await fetch("{{ url_for('scan.archive_emails') }}", {
                    method: 'POST',
                    body: formData
                });
                
                const archiveResult = await response.json();
                
                if (!response.ok || !archiveResult.success) {
                    console.error('Archive operation failed:', archiveResult.message || archiveResult.error);
                    
                    // Check for permissions issue (status 403)
                    if (response.status === 403 && archiveResult.details && archiveResult.details.reason) {
                        // This is a permissions issue - show the user a manual archive instruction
                        console.log("Permission issue detected:", archiveResult.details.reason);
                        errors.push(archiveResult.message);
                        if (archiveResult.details.help_text) {
                            errors.push(archiveResult.details.help_text);
                        }
                    } else if (archiveResult.details && archiveResult.details.archive_errors) {
                        errors.push(...archiveResult.details.archive_errors);
                    } else {
                        errors.push('Failed to archive some emails');
                    }
                }
                
            } catch (error) {
                console.error('Error during archive operation:', error);
                errors.push(`Network error during archiving: ${error.message}`);
            }
        }
        
        // Final update to UI
        // Consider all selected emails as "processed" for UI and cleanup purposes
        window.processedEmailIds = [...selectedIdsFromStorage];
        
        // Construct final message
        const successCount = successfullyProcessedIds.length;
        const manualCount = manuallyRequiredIds.length;
        const failCount = failedIds.length;
        
        let message = '';
        
        if (successCount > 0) {
            message += `Automatically processed ${successCount} email${successCount !== 1 ? 's' : ''}.`;
        }
        
        if (manualCount > 0) {
            if (message) message += ' ';
            message += `${manualCount} email${manualCount !== 1 ? 's' : ''} require manual action.`;
        }
        
        if (failCount > 0) {
            if (message) message += ' ';
            message += `${failCount} email${failCount !== 1 ? 's' : ''} failed.`;
        }
        
        if (shouldArchive) {
            if (message) message += ' ';
            const archivedCount = selectedIdsFromStorage.length;
            message += `Archived ${archivedCount} email${archivedCount !== 1 ? 's' : ''}.`;
        }
        
        // Get all manual links for display in the result modal
        const manualLinks = {};
        
        // Collect links for emails requiring manual action
        for (const sender of Object.keys(httpLinks)) {
            if (senderMap[sender] && senderMap[sender].some(id => manuallyRequiredIds.includes(id))) {
                manualLinks[sender] = httpLinks[sender];
            }
        }
        
        for (const sender of Object.keys(mailtoLinks)) {
            if (senderMap[sender] && senderMap[sender].some(id => manuallyRequiredIds.includes(id))) {
                manualLinks[sender] = mailtoLinks[sender];
            }
        }
        
        const resultData = {
            success: failCount === 0,
            message: message.trim(),
            details: {
                unsubscribe_errors: errors,
                processed_senders: senders,
                processed_email_ids: window.processedEmailIds,
                manual_links: manualLinks,
                manual_count: manualCount
            },
            http_link: lastHttpLink,
            has_manual_actions: manualCount > 0
        };
        
        // Show completion modal
        showModal(renderSuccessModalContent(resultData.message, resultData.http_link, resultData));
        
        // Store the senders that were part of this batch
        storeProcessedSenders(senders);
        markProcessedSenders(); // Immediately mark them on the current page
        
        // Clear selection storage on successful processing
        saveSelectedEmailsToStorage([]);
        saveEmailDetailsToStorage({});
        
        hideLoading(buttonId);
    }
    
    function showUnsubscribeProgressModal(senders) {
        const totalSenders = senders.length;
        let sendersHtml = '';
        
        // Get HTTP links from sender map
        const httpLinks = {};
        const mailtoLinks = {};
        
        // Generate a list of senders with progress indicators
        senders.forEach((sender, index) => {
            // Store link info for each sender
            const senderId = sender.replace(/\s+/g, '-')
                .replace(/[<>]/g, '')
                .replace(/@/g, '-')
                .replace(/\./g, '-');
                
            const senderGroup = document.getElementById(`sender-group-${senderId}`);
            let link = '';
            let linkType = '';
            
            if (senderGroup) {
                const headerLinks = senderGroup.querySelectorAll('.sender-header a');
                if (headerLinks.length > 0) {
                    link = headerLinks[0].getAttribute('href') || '';
                    linkType = link.startsWith('mailto:') ? 'mailto' : 'http';
                    
                    if (linkType === 'mailto') {
                        mailtoLinks[sender] = link;
                    } else if (linkType === 'http') {
                        httpLinks[sender] = link;
                    }
                }
            }
            
            sendersHtml += `
            <div class="sender-progress-item flex items-center justify-between py-2 border-b border-border last:border-0" data-sender="${sender}">
                <span class="text-sm text-foreground truncate max-w-[200px]" title="${sender}">${sender}</span>
                <span class="status-indicator flex items-center gap-2">
                    <span class="status-text text-xs text-muted-foreground mr-1">Waiting</span>
                    <div class="loading-spinner w-4 h-4 hidden">
                        <svg class="animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <svg class="check-icon w-4 h-4 text-success hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                    </svg>
                    <svg class="warning-icon w-4 h-4 text-warning hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                    </svg>
                    <a href="#" class="action-button hidden text-xs btn" data-link="${link}">&nbsp;</a>
                </span>
            </div>`;
        });

        // Add explanation about manual action requirement
        const explanationNote = `
        <div class="mb-3 text-xs text-foreground">
            <div class="flex items-center mb-2 text-sm">
                <svg class="check-icon w-4 h-4 text-success mr-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                </svg>
                <span>Automatic Unsubscribe</span>
            </div>
            <div class="flex items-center text-sm">
                <svg class="warning-icon w-4 h-4 text-warning mr-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                </svg>
                <span>Manual Action Required</span>
            </div>
        </div>`;

        const progressModalHtml = `
        <div class="bg-background rounded-lg p-6">
            <div class="mb-4 text-center">
                <h3 class="text-xl font-semibold text-foreground">Unsubscribing...</h3>
                <p class="text-sm text-muted-foreground mt-2">Processing unsubscribe requests for selected emails.</p>
            </div>
            
            <div class="relative pt-1 mb-4">
                <div class="w-full bg-muted rounded-full">
                    <div id="progress-bar" class="bg-brand h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <div class="flex justify-between text-xs text-muted-foreground mt-1">
                    <span id="progress-text">0/${totalSenders} senders</span>
                    <span id="progress-percentage">0%</span>
                </div>
            </div>
            
            ${explanationNote}
            
            <div class="max-h-60 overflow-y-auto border border-border rounded-md p-2">
                <div id="sender-progress-list">
                    ${sendersHtml}
                </div>
            </div>
        </div>`;
        
        showModal(progressModalHtml);
        
        // Start the first item as processing
        if (senders.length > 0) {
            updateSenderStatus(senders[0], 'processing');
        }
        
        // Return the link maps for use in processing
        return { httpLinks, mailtoLinks };
    }
    
    function updateProgress(completedCount) {
        const totalCount = window.totalSendersToProcess || 1;
        const progressPercent = Math.floor((completedCount / totalCount) * 100);
        
        // Update the progress bar
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const progressPercentage = document.getElementById('progress-percentage');
        
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
        if (progressText) progressText.innerText = `${Math.floor(completedCount)}/${totalCount} senders`;
        if (progressPercentage) progressPercentage.innerText = `${progressPercent}%`;
        
        // Mock the progress of sender processing for visual feedback
        const senders = Object.keys(getSenderMap());
        
        if (window.currentSenderIndex < senders.length) {
            // Update the current sender to 'processing'
            const currentSender = senders[window.currentSenderIndex];
            updateSenderStatus(currentSender, 'processing');
            
            // Mark previous senders as 'completed'
            if (window.currentSenderIndex > 0) {
                const previousSender = senders[window.currentSenderIndex - 1];
                updateSenderStatus(previousSender, 'completed');
                window.currentSenderIndex++;
            } else {
                window.currentSenderIndex++;
            }
        }
    }
    
    function getSenderMap() {
        const senderMap = {};
        for (const emailId of window.processedEmailIds || []) {
            const checkbox = document.querySelector(`.email-checkbox[value="${emailId}"]`);
            if (checkbox) {
                const sender = checkbox.getAttribute('data-sender');
                if (sender) {
                    if (!senderMap[sender]) {
                        senderMap[sender] = [];
                    }
                    senderMap[sender].push(emailId);
                }
            }
        }
        return senderMap;
    }
    
    function updateSenderStatus(sender, status, linkType = null) {
        const senderItem = document.querySelector(`.sender-progress-item[data-sender="${sender}"]`);
        if (!senderItem) return;
        
        const statusText = senderItem.querySelector('.status-text');
        const spinner = senderItem.querySelector('.loading-spinner');
        const checkIcon = senderItem.querySelector('.check-icon');
        const warningIcon = senderItem.querySelector('.warning-icon');
        const actionButton = senderItem.querySelector('.action-button');
        
        // Reset all indicators
        spinner.classList.add('hidden');
        checkIcon.classList.add('hidden');
        warningIcon?.classList.add('hidden');
        if (actionButton) actionButton.classList.add('hidden');
        
        if (status === 'waiting') {
            if (statusText) statusText.innerText = 'Waiting';
        } else if (status === 'processing') {
            if (statusText) statusText.innerText = 'Processing';
            spinner.classList.remove('hidden');
        } else if (status === 'completed') {
            if (statusText) statusText.innerText = 'Completed';
            checkIcon.classList.remove('hidden');
        } else if (status === 'manual') {
            if (statusText) statusText.innerText = 'Manual Action Required';
            if (warningIcon) warningIcon.classList.remove('hidden');
            if (actionButton) {
                actionButton.classList.remove('hidden');
                // If we stored the link with the button, set it to be openable
                if (actionButton.dataset.link && linkType) {
                    actionButton.href = actionButton.dataset.link;
                    actionButton.target = "_blank";
                    actionButton.classList.add('btn-sm', 'btn-outline-warning');
                    actionButton.textContent = linkType === 'mailto' ? 'Send Email' : 'Open Link';
                }
            }
        } else if (status === 'error') {
            if (statusText) statusText.innerText = 'Failed';
            if (warningIcon) warningIcon.classList.remove('hidden');
        }
    }

    async function performArchiveActionOnly() {
        const selectedIdsFromStorage = getSelectedEmailsFromStorage(); // Get ALL selected IDs
        if (selectedIdsFromStorage.length === 0) {
            alert('Please select at least one email to archive.');
            return;
        }
        
        // Store the IDs we are about to process for removal later
        window.processedEmailIds = [...selectedIdsFromStorage];

        const buttonId = 'archive-only-button';
        setLoading(buttonId, 'Archiving...');

        const formData = new FormData();
        // Send ALL selected IDs from storage to the backend
        selectedIdsFromStorage.forEach(id => formData.append('email_ids', id));
        
        const url = "{{ url_for('scan.archive_emails') }}"; 

        try {
            const response = await fetch(url, {
                method: 'POST',
                body: formData
            });
            const resultData = await response.json(); // Expect JSON

            if (response.ok && resultData.success) {
                showModal(renderSuccessModalContent(resultData.message));
                // Clear storage ONLY on successful processing of ALL items
                saveSelectedEmailsToStorage([]);
                saveEmailDetailsToStorage({});
            } else {
                 // Check for permission issues
                 if (response.status === 403 && resultData.details && resultData.details.reason) {
                     // Create a more helpful error message for permission issues
                     let permissionMessage = resultData.message || "Archiving emails requires additional permissions";
                     if (resultData.details.help_text) {
                         permissionMessage += "\n\n" + resultData.details.help_text;
                     }
                     showModal(renderErrorModalContent(permissionMessage));
                 } else {
                     const errorMessage = resultData.error || resultData.message || `Request failed with status ${response.status}`;
                     showModal(renderErrorModalContent(errorMessage));
                 }
                 window.processedEmailIds = []; // Don't remove items or clear storage on failure
            }

        } catch (error) {
            console.error('Error archiving:', error);
            showModal(renderErrorModalContent('Network error occurred during archiving. Please try again.'));
             window.processedEmailIds = [];
        } finally {
            hideLoading(buttonId);
             // Action bar update happens in closeModal or removeProcessedEmails
        }
    }

    function showModal(content) {
        const modal = document.getElementById('result-modal');
        const modalContent = document.getElementById('modal-content');
        modalContent.innerHTML = content;
        modal.classList.remove('modal-hidden');
    }

    function closeModal() {
        const modal = document.getElementById('result-modal');
        modal.classList.add('modal-hidden');
        document.getElementById('modal-content').innerHTML = ''; // Clear content
        updateActionBar(); // Update after closing modal
    }
    
    // Global functions for modal buttons
    window.removeProcessedEmails = function() {
        const listContainer = document.getElementById('subscription-list');
        
        // Use the stored processedEmailIds set during the action call
        if (window.processedEmailIds && window.processedEmailIds.length > 0) {
            console.log(`Removing ${window.processedEmailIds.length} processed emails from view`);
            
            window.processedEmailIds.forEach(emailId => {
                const emailRow = document.getElementById(`email-${emailId}`);
                if (!emailRow) {
                    console.warn(`Could not find email row with ID: email-${emailId}`);
                    return;
                }
                
                const checkbox = emailRow.querySelector('.email-checkbox');
                const sender = checkbox?.dataset.sender;
                
                // Remove the email row from DOM
                emailRow.remove();
                console.log(`Removed email ID: ${emailId}`);
                
                // Check if sender group is now empty
                if (sender) {
                    // Use the same regex pattern as in other parts of the code
                    const senderId = sender.replace(/\s+/g, '-')
                        .replace(/[<>]/g, '')
                        .replace(/@/g, '-')
                        .replace(/\./g, '-');
                    
                    const senderGroup = document.getElementById(`sender-group-${senderId}`);
                    if (!senderGroup) {
                        console.warn(`Could not find sender group for: ${sender}, ID: ${senderId}`);
                        return;
                    }
                    
                    // Check if the email list div exists and has no more email rows
                    const emailsDiv = senderGroup.querySelector('.sender-emails');
                    if (emailsDiv && emailsDiv.querySelectorAll('.email-row').length === 0) {
                        senderGroup.remove();
                        console.log(`Removed empty sender group: ${sender}`);
                    }
                }
            });
            window.processedEmailIds = []; // Clear the list
        }
        
        // Check if the list is empty AFTER removing items
        if (listContainer && listContainer.querySelectorAll('.sender-group').length === 0) {
            console.log("Subscription list is now empty.");
            const scanMoreButton = document.getElementById('scan-more-button');
            if (scanMoreButton) {
                console.log("Next page token exists, automatically clicking 'Scan More Emails'.");
                scanMoreButton.click(); // Trigger loading next page
            } else {
                console.log("No next page token, displaying final message.");
                // Display a final message if no more pages
                const contentContainer = document.querySelector('.content-container'); 
                if (contentContainer) {
                     contentContainer.innerHTML = `
                        <div class="card p-8 text-center max-w-lg mx-auto mt-10" style="opacity: 0; animation: scaleIn 0.5s ease forwards; animation-delay: 0.1s;">
                            <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-12 w-12 text-success mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            <h3 class="text-lg font-medium text-foreground mb-2">All Done!</h3>
                            <p class="text-muted-foreground mb-6">You've processed all the subscription emails found based on the scan criteria.</p>
                            <a href="{{ url_for('index') }}" class="btn btn-secondary mt-4 focus-ring">Back Home</a>
                        </div>
                    `;
                }
            }
        }
        
        closeModal(); // This calls updateActionBar which reads the (now empty) storage
    }

    window.closeErrorMessage = function() {
        closeModal();
    }
    
    function showPermissionModal() {
        const modal = document.getElementById('permission-modal');
        if (modal) {
            modal.classList.remove('modal-hidden');
        }
    }
    
    function closePermissionModal() {
        const modal = document.getElementById('permission-modal');
        if (modal) {
            modal.classList.add('modal-hidden');
        }
    }

    // Render success modal content dynamically with processed senders summary
    function renderSuccessModalContent(message, http_link = null, resultData = null) {
        console.log("Rendering success modal with:", { message, http_link, resultData });
        
        // Get the list of senders that were processed
        let senders = [];
        let processedEmailIds = [];
        let manualLinks = {};
        let manualCount = 0;
        
        // First try to use the backend-provided processed senders list
        if (resultData && resultData.details) {
            if (resultData.details.processed_senders) {
                senders = resultData.details.processed_senders;
                console.log(`Found ${senders.length} processed senders from backend data`);
            }
            
            // If server returned processed email IDs, use those
            if (resultData.details.processed_email_ids) {
                processedEmailIds = resultData.details.processed_email_ids;
                console.log(`Found ${processedEmailIds.length} processed email IDs from backend data`);
                // Update the window.processedEmailIds to ensure we only remove properly processed emails
                window.processedEmailIds = processedEmailIds;
            }
            
            // Get manual links if available
            if (resultData.details.manual_links) {
                manualLinks = resultData.details.manual_links;
            }
            
            if (resultData.details.manual_count) {
                manualCount = resultData.details.manual_count;
            }
        }
        
        // Fall back to client-side tracking if backend data not available
        if (senders.length === 0) {
            const senderMap = getSenderMap();
            senders = Object.keys(senderMap);
            console.log(`Using client-side fallback, found ${senders.length} senders`);
        }
        
        // Prepare a summary of processed senders
        let senderSummary = '';
        if (senders.length > 0) {
            const maxSendersToShow = 5; // Limit the number of senders shown to avoid cluttering the modal
            const displayedSenders = senders.slice(0, maxSendersToShow);
            const remainingSenders = senders.length - maxSendersToShow;
            
            let sendersList = displayedSenders.map(sender => {
                // Check if this sender requires manual action
                const requiresManual = manualLinks && manualLinks[sender];
                const linkType = requiresManual && manualLinks[sender].startsWith('mailto:') ? 'Email' : 'Link';
                
                return `<li class="text-sm text-foreground py-1 flex items-center justify-between">
                    <div class="flex items-center">
                        ${requiresManual ? 
                            `<svg class="w-4 h-4 text-warning mr-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>` : 
                            `<svg class="w-4 h-4 text-success mr-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                            </svg>`
                        }
                        <span class="truncate max-w-[200px]" title="${sender}">${sender}</span>
                    </div>
                    ${requiresManual && manualLinks[sender] ? 
                        `<a href="${manualLinks[sender]}" target="_blank" class="text-xs text-brand hover:underline ml-2">
                            ${linkType}
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 inline-block ml-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                            </svg>
                        </a>` : 
                        ''
                    }
                </li>`;
            }).join('');
            
            if (remainingSenders > 0) {
                sendersList += `<li class="text-sm text-muted-foreground py-1">And ${remainingSenders} more sender${remainingSenders > 1 ? 's' : ''}...</li>`;
            }
            
            const summaryTitle = manualCount > 0 ? 
                "Processed senders (⚠️ some require manual action):" : 
                "Processed senders:";
            
            senderSummary = `
            <div class="mt-4 text-left w-full">
                <h4 class="text-sm font-medium text-foreground mb-1">${summaryTitle}</h4>
                <ul class="border border-border rounded-md p-2 max-h-60 overflow-y-auto">
                    ${sendersList}
                </ul>
            </div>`;
        }
        
        // Include manual action section if needed
        let manualActionSection = '';
        
        if (manualCount > 0) {
            // Count manual links types
            const httpLinkCount = Object.values(manualLinks).filter(link => link.startsWith('http')).length;
            const mailtoLinkCount = Object.values(manualLinks).filter(link => link.startsWith('mailto')).length;
            
            manualActionSection = `
            <div class="mt-4 p-4 border border-warning rounded-md bg-warning/5 text-sm w-full">
                <div class="flex items-start">
                    <svg class="w-5 h-5 text-warning mr-2 mt-0.5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                    </svg>
                    <div>
                        <h4 class="font-medium text-warning-foreground mb-1">Manual Action Required</h4>
                        <p class="mb-3 text-muted-foreground">Some unsubscribe requests couldn't be processed automatically. Please use the links next to each sender to complete the unsubscription.</p>
                        <div class="flex flex-wrap gap-2 text-xs">
                            ${httpLinkCount > 0 ? 
                                `<span class="inline-flex items-center px-2 py-1 rounded-full bg-warning/10 text-warning-foreground">
                                    <svg class="w-3 h-3 mr-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101" />
                                    </svg>
                                    ${httpLinkCount} Web Link${httpLinkCount !== 1 ? 's' : ''}
                                </span>` : ''
                            }
                            ${mailtoLinkCount > 0 ? 
                                `<span class="inline-flex items-center px-2 py-1 rounded-full bg-warning/10 text-warning-foreground">
                                    <svg class="w-3 h-3 mr-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                                    </svg>
                                    ${mailtoLinkCount} Email Link${mailtoLinkCount !== 1 ? 's' : ''}
                                </span>` : ''
                            }
                        </div>
                    </div>
                </div>
            </div>`;
        }
        
        // Determine what icon to show in the header
        const iconHtml = manualCount > 0 ? 
            `<div class="warning-container mb-4">
                <svg class="warning-large" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" fill="none" stroke="#ffcc00" stroke-width="2">
                    <circle cx="26" cy="26" r="24" fill="none"/>
                    <path d="M26 15v15" stroke-linecap="round"/>
                    <circle cx="26" cy="37" r="2" fill="#ffcc00"/>
                </svg>
            </div>` :
            `<div class="checkmark-container mb-4">
                <svg class="checkmark" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
                    <circle class="checkmark-circle" cx="26" cy="26" r="25" fill="none"/>
                    <path class="checkmark-check" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8"/>
                </svg>
            </div>`;
        
        const titleHtml = manualCount > 0 ? 
            `<h3 class="text-xl font-semibold text-warning mb-2">Action Required</h3>` :
            `<h3 class="text-xl font-semibold text-success mb-2">Success!</h3>`;
            
        return `
        <div class="bg-background rounded-lg p-6 flex flex-col items-center">
            <div class="text-center flex flex-col items-center">
                ${iconHtml}
                ${titleHtml}
                <p class="text-foreground">${message || "Operation completed successfully."}</p>
            </div>
            
            ${senderSummary}
            ${manualActionSection}
            
            <button 
                class="mt-6 btn btn-brand btn-sm focus-ring w-full"
                onclick="window.removeProcessedEmails()">
                Done
            </button>
        </div>`;
    }

    // Render error modal content dynamically (no changes needed here, already good)
    function renderErrorModalContent(message) {
        return `
        <div class="bg-background rounded-lg p-6 text-center flex flex-col items-center">
            <div class="error-container mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 text-destructive" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                </svg>
            </div>
            <h3 class="text-xl font-semibold text-destructive mb-2">Error</h3>
            <p class="text-muted-foreground">${message}</p>
            <button 
                class="mt-4 btn btn-outline btn-sm focus-ring"
                onclick="closeModal()">
                Close
            </button>
        </div>`;
    }

    function resetSelection() {
        console.log("Resetting selection...");
        // Clear storage
        saveSelectedEmailsToStorage([]);
        saveEmailDetailsToStorage({}); // Also clear email details storage
        
        // Uncheck all visible checkboxes
        document.querySelectorAll('.email-checkbox:checked').forEach(cb => {
            cb.checked = false;
        });
        document.querySelectorAll('.sender-checkbox:checked').forEach(cb => {
            cb.checked = false;
            cb.indeterminate = false; // Reset indeterminate state
        });
        
        // Remove visual selection state from visible rows/groups
        document.querySelectorAll('.email-selected').forEach(row => {
            row.classList.remove('email-selected');
        });
        document.querySelectorAll('.sender-selected').forEach(group => {
            group.classList.remove('sender-selected');
        });
        
        // Update the action bar (which will now hide itself)
        updateActionBar();
    }

</script>
{% endblock %} 